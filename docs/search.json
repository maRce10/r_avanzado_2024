[
  {
    "objectID": "fundamentos_de_r.html",
    "href": "fundamentos_de_r.html",
    "title": "Elementos básicos del lenguaje R",
    "section": "",
    "text": "Familiarizarse con los bloques básicos en R y su manipilación\nConocer las fuentes principales de documentación estandarizada en R"
  },
  {
    "objectID": "fundamentos_de_r.html#section",
    "href": "fundamentos_de_r.html#section",
    "title": "Elementos básicos del lenguaje R",
    "section": "2.1  ",
    "text": "2.1"
  },
  {
    "objectID": "fundamentos_de_r.html#objetos-que-contienen-datos",
    "href": "fundamentos_de_r.html#objetos-que-contienen-datos",
    "title": "Elementos básicos del lenguaje R",
    "section": "3.1 Objetos que contienen datos",
    "text": "3.1 Objetos que contienen datos\nLa estructura de datos básica en R es el vector. Con este se contruyen todas las otras clases de objetos. Para entender las clases es útil pensar en el número de dimensiones (1, 2 o mas) y tipos de datos que pueden contener: homogéneos (un único tipo de elemento) o homogéneos (o múltiples tipos de elementos).\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    D(Objetos de Datos) --&gt; D1(1 dimension)\n    D --&gt; D2(2 dimensiones)\n    D1 --&gt; V(Vector)\n    D1 --&gt; L(Lista)\n    D2 --&gt; M(Matriz)\n    D2 --&gt;  DF(\"Cuadro de Datos &lt;br&gt;(Data Frame)\")\n\n    style D fill:#40498E66, stroke:#000, stroke-width:2px, color:#FFF, width:180px\n    style D1 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style D2 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style DF fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style V fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style M fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style L fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHomogéneo\nHeterogéneo\n\n\n\n\n1d\nVector atómico\nLista\n\n\n2d\nMatriz\nCuadro de datos (data frame)\n\n\nnd\narreglo (Array)\n\n\n\n\n\n\n\n\n3.1.1 Objetos de 1 dimensión\nHay dos tipos básicos de vectores: vectores atómicos y listas.\nTienen tres propiedades comunes:\n\nTipo, typeof() (clase/modo ~)\nLongitud, length() (número de elementos)\nAttributes, attributes() (metadatos)\n\nSe diferencian en los tipos de sus elementos: todos los elementos de un vector atómico deben ser del mismo tipo, mientras que los elementos de una lista pueden tener diferentes tipos.\n\n3.1.1.1 Vectores atomicos\nTipos de vectores atómicos:\n\nLógico (booleano)\nEntero\nNumérico (doble)\nCaracteres\nFactores\n\nLos vectores se construyen con la función c(), Pueden ser numérico:\n\n\nCódigo\nx &lt;- 1\nx1 &lt;- c(1)\n\nall.equal(x, x1)\n\n\n[1] TRUE\n\n\nCódigo\nclass(x)\n\n\n[1] \"numeric\"\n\n\nDe caracteres:\n\n\nCódigo\ny &lt;- \"algo\"\n\nclass(y)\n\n\n[1] \"character\"\n\n\nLógico:\n\n\nCódigo\nz &lt;- TRUE\n\nclass(z)\n\n\n[1] \"logical\"\n\n\nO factor:\n\n\nCódigo\nq &lt;- factor(1)\n\nclass(q)\n\n\n[1] \"factor\"\n\n\n \nPor tanto, los números o cadenas individuales son en realidad vectores de longitud uno:\n\n\nCódigo\nclass(1)\n\n\n[1] \"numeric\"\n\n\nCódigo\nclass(\"a\")\n\n\n[1] \"character\"\n\n\nLos vectores sólo pueden contener elementos del mismo tipo. Los tipos diferentes de elementos serán forzados al tipo más flexible:\n\n\nCódigo\nx &lt;- c(1, 2, \"a\")\n\nx\n\n\n[1] \"1\" \"2\" \"a\"\n\n\nCódigo\nclass(x)\n\n\n[1] \"character\"\n\n\n \nLos valores que faltan se especifican con NA, que es un vector lógico de longitud 1. NA siempre será interpretado al tipo correcto si se utiliza dentro de c():\n\n\nCódigo\nv &lt;- c(10, 11, NA)\n\nclass(v)\n\n\n[1] \"numeric\"\n\n\nCódigo\nv &lt;- c(\"a\", \"b\", NA)\n\nclass(v)\n\n\n[1] \"character\"\n\n\n\n\n3.1.1.2 Factores\nLos vectores con factores son muy simulares a los de caracteres. Sin embargo, un factor sólo puede contener valores predefinidos, conocidos como niveles. Los atributos se utilizan para definir los niveles del factor.\nLos factores se construyen sobre vectores enteros utilizando dos atributos:\n\nclase “factor”: hace que se comporten de forma diferente a los vectores de caracteres normales\nniveles: define el conjunto de valores permitidos\n\n\n\nCódigo\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n\n[1] a b b a\nLevels: a b\n\n\nCódigo\nlevels(x)\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nstr(x)\n\n\n Factor w/ 2 levels \"a\",\"b\": 1 2 2 1\n\n\n \nLos factores parecen vectores de caracteres, pero en realidad son números enteros:\n\n\nCódigo\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\n\nc(x)\n\n\n[1] a b b a\nLevels: a b\n\n\n\n\n3.1.1.3 Listas\nPuede contener objetos de diferentes clases y tamaños. Las listas se construyen con list():\n\n\nCódigo\nl &lt;- list(\"a\", 1, FALSE)\n\nl\n\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] FALSE\n\n\nCódigo\nclass(l)\n\n\n[1] \"list\"\n\n\nCódigo\nstr(l)\n\n\nList of 3\n $ : chr \"a\"\n $ : num 1\n $ : logi FALSE\n\n\nEn realidad pueden ser vistas como cajones donde se pueden poner cualquier otro tipo de objeto:\n\n\nCódigo\nl &lt;- list(c(\"a\", \"b\"), c(1, 2, 3, 4), c(FALSE, TRUE, FALSE))\n\nl\n\n\n[[1]]\n[1] \"a\" \"b\"\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] FALSE  TRUE FALSE\n\n\nCódigo\nstr(l)\n\n\nList of 3\n $ : chr [1:2] \"a\" \"b\"\n $ : num [1:4] 1 2 3 4\n $ : logi [1:3] FALSE TRUE FALSE\n\n\n\n\n\n3.1.2 Objetos de 2 dimensiones\n\n\n3.1.3 Matrices\nTodas los elementos son del mismo tipo:\n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\ndim(m)\n\n\n[1] 2 3\n\n\nCódigo\nm\n\n\n     [,1] [,2] [,3]\n[1,]    1    3   12\n[2,]    2   11   13\n\n\nCódigo\nclass(m)\n\n\n[1] \"matrix\" \"array\" \n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, \"13\"), nrow = 2)\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"3\"  \"12\"\n[2,] \"2\"  \"11\" \"13\"\n\n\n \n\n\n3.1.4 Cuadros de datos (data frames)\nCaso especial de las listas. Puede contener elementos de diferentes tipos:\n\n\nCódigo\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\ndim(m)\n\n\n[1] 5 3\n\n\nCódigo\nm\n\n\n\n\n\n\nID\nsize\nobserved\n\n\n\n\na\n1\nFALSE\n\n\nb\n2\nTRUE\n\n\nc\n3\nFALSE\n\n\nd\n4\nFALSE\n\n\ne\n5\nFALSE\n\n\n\n\n\n\nCódigo\nclass(m)\n\n\n[1] \"data.frame\"\n\n\nCódigo\nis.data.frame(m)\n\n\n[1] TRUE\n\n\nCódigo\nis.list(m)\n\n\n[1] TRUE\n\n\nCódigo\nstr(m)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ ID      : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num  1 2 3 4 5\n $ observed: logi  FALSE TRUE FALSE FALSE FALSE\n\n\n \nPero los vectores deben tener la misma longitud:\n\n\nCódigo\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5, 6),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\n\nError in data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, : arguments imply differing number of rows: 5, 6\n\n\n \n\n\n3.1.5 Ejercicio 1\n \n\nCree un vector numérico con 8 elementos que contenga números positivos y negativos\nCree un vector de caracteres con los nombres de las provincias de Costa Rica\nAñada al vector de punto anterior un NA\nCree una matriz numérica con 3 columnas y 3 filas\nCree una matriz de caracteres con 4 columnas y 3 filas\n¿Qué tipo de objeto es ‘iris’ y cuales son sus dimensiones? (pista: iris es un objeto disponible por omisión en su ambiente)\nCree un cuadro de datos (data frame) con una columna numérica, una columna de caracteres y una columna con factores"
  },
  {
    "objectID": "fundamentos_de_r.html#funciones-objetos-que-hacen-tareas",
    "href": "fundamentos_de_r.html#funciones-objetos-que-hacen-tareas",
    "title": "Elementos básicos del lenguaje R",
    "section": "3.2 Funciones: objetos que hacen tareas",
    "text": "3.2 Funciones: objetos que hacen tareas\nTodas las funciones se crean con la función function() y siguen la misma estructura:\n\n* Modified from Grolemund 2014  \n\n3.2.1 Funciones integradas\n\n3.2.1.1 Funciones básicas\nR viene con muchas funciones que puedes usar para hacer tareas sofisticadas:\n\n\nCódigo\n# built in functions\nbi &lt;- builtins(internal = FALSE)\n\nlength(bi)\n\n\n[1] 1402\n\n\n \nAlgunas funciones vienen de forma predeterminada con R básico. Nuevas funciones pueden ser cargadas como parte de paquetes adicionales o incluso creadas por el usuario.\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    F(Funciones) --&gt; BF(Funciones Integradas)\n    BF --&gt; OP(Operadores)\n    BF --&gt; BA(Funciones Básicas)\n    F --&gt; PF(Paquetes)\n    F --&gt; UF(Funciones Definidas por el Usuario)\n\n    class R,D,D1,D2,F largeText;\n\n    style F fill:#357BA266, stroke:#000, stroke-width:2px, color:#FFF, width:120px\n    style BF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n    style BA fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000\n    style OP fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000    \n    style PF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000000\n    style UF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n3.2.1.2 Operadores\nLos operadores son funciones:\n\n\nCódigo\n1 + 1\n\n\n[1] 2\n\n\nCódigo\n'+'(1, 1)\n\n\n[1] 2\n\n\nCódigo\n2 * 3\n\n\n[1] 6\n\n\nCódigo\n'*'(2, 3)\n\n\n[1] 6\n\n\n \n\n3.2.1.2.1 Operadores mas utilizados\nOperadores aritméticos:\n\n\n\n\n\n\n\nOperador\nDescrición\n\n\n\n\n+\nsuma\n\n\n-\nresta\n\n\n*\nmultiplicación\n\n\n/\ndivisión\n\n\n^ or **\nexponente\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n1 - 2\n\n\n[1] -1\n\n\nCódigo\n1 + 2\n\n\n[1] 3\n\n\nCódigo\n2 ^ 2\n\n\n[1] 4\n\n\nCódigo\n2 ** 2\n\n\n[1] 4\n\n\n \nOperadores lógicos:\n\n\n\nOperador\nDescrición\n\n\n\n\n&lt;\nmenor que\n\n\n&lt;=\nmenor o igual que\n\n\n&gt;\nmayor que\n\n\n&gt;=\nmayor o igual que\n\n\n==\nexactamente igual que\n\n\n!=\ndiferente que\n\n\n!x\nNo es x\n\n\nx | y\nx O y\n\n\nx & y\nx Y y\n\n\nx %in% y\ncorrespondencia\n\n\n\n\n\nCódigo\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 == 2\n\n\n[1] FALSE\n\n\nCódigo\n1 != 2\n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCódigo\n5 %in% 1:4\n\n\n[1] FALSE\n\n\nLos paréntesis utilizados para extraer subconjuntos de objetos también son funciones:\n\n\nCódigo\nletters[3:4]\n\n\n[1] \"c\" \"d\"\n\n\nCódigo\n\"[\"(letters, 3:4)\n\n\n[1] \"c\" \"d\"\n\n\n \n\n\n\n\n3.2.2 Vectorización\nLa mayoría de las funciones están vectorizadas:\n\n\nCódigo\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCódigo\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recicla vectores de longitud desigual:\n\n\nCódigo\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n\n \n\n3.2.3 Funciones de paquetes adicionales\nEstas son funciones que son incluidas en paquetes adicionales que se pueden instalar y cargar en R. Para ser utilizadas el paquete debe ser instalado y cargado.Por ejemplo para usar la función corTest del paquete “psych” primero debemos instalar. Los paquetes son instalados del servidor de CRAN (Comprehensive R Archive Network) con la función install.packages():\n\n\nCódigo\ninstall.packages(\"psych\")\n\n\n.. y cargar el paquete:\n\n\nCódigo\nlibrary(psych)\n\n\nUna vez instalado y cargado ‘psych’, podemos llamar a la función corTest:\n\n\nCódigo\ncorTest(iris$Sepal.Length, iris$Sepal.Width)\n\n\nCall:corTest(x = iris$Sepal.Length, y = iris$Sepal.Width)\nCorrelation matrix \n[1] -0.12\nSample Size \n[1] 150\nThese are the unadjusted probability values.\n  The probability values  adjusted for multiple tests are in the p.adj object. \n[1] 0.15\n\n To see confidence intervals of the correlations, print with the short=FALSE option\n\n\nEl uso de paquetes externos es la caracteristica mas util de R ya que permite hacer uso de un número casi infinito de funciones especializadas en diferentes tareas así como de campos muy diversos de la ciencia y la industria.\nPodemos explorar los paquetes disponibles para R en la página de CRAN (hacer click en el enlace “packages”).\n\n\n3.2.4 Ejercicio 2\n \n\nBusque un paquete que le interese en CRAN\nInstale el paquete y carguelo\nCorra el codigo de ejemplo de una de sus funciones"
  },
  {
    "objectID": "fundamentos_de_r.html#extraer-subconjuntos-usando-indexación-indexing",
    "href": "fundamentos_de_r.html#extraer-subconjuntos-usando-indexación-indexing",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.1 Extraer subconjuntos usando indexación (indexing)",
    "text": "4.1 Extraer subconjuntos usando indexación (indexing)\nLos elementos dentro de los objetos pueden ser llamados por medio de la indexación. Para sub-conjuntar un vector simplemente llame a la posición del objeto usando corchetes:\n\n\nCódigo\nx &lt;- c(1, 3, 4, 10, 15, 20, 50, 1, 6)\n\nx[1]\n\n\n[1] 1\n\n\nCódigo\nx[2]\n\n\n[1] 3\n\n\nCódigo\nx[2:3]\n\n\n[1] 3 4\n\n\nCódigo\nx[c(1,3)]\n\n\n[1] 1 4\n\n\n \nLos elementos se pueden eliminar de la misma manera:\n\n\nCódigo\nx[-1]\n\n\n[1]  3  4 10 15 20 50  1  6\n\n\nCódigo\nx[-c(1,3)]\n\n\n[1]  3 10 15 20 50  1  6\n\n\n \nLas matrices y los marcos de datos requieren 2 índices [fila, columna]:\n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\nm[1, ]\n\n\n[1]  1  3 12\n\n\nCódigo\nm[, 1]\n\n\n[1] 1 2\n\n\nCódigo\nm[1, 1]\n\n\n[1] 1\n\n\nCódigo\nm[-1, ]\n\n\n[1]  2 11 13\n\n\nCódigo\nm[, -1]\n\n\n     [,1] [,2]\n[1,]    3   12\n[2,]   11   13\n\n\nCódigo\nm[-1, -1]\n\n\n[1] 11 13\n\n\nCódigo\ndf &lt;- data.frame(\n  provincia = c(\"San José\", \"Guanacaste\", \"Guanacaste\"), \n  canton = c(\"Montes de Oca\", \"Nicoya\", \"Liberia\"), \n    distrito = c(\"San Rafael\", \"Nosara\", \"Nacascolo\")\n  )\n\ndf\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[1, ]\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\n\n\n\n\nCódigo\ndf[, 1]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCódigo\ndf[1, 1]\n\n\n[1] \"San José\"\n\n\nCódigo\ndf[-1, ]\n\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\n2\nGuanacaste\nNicoya\nNosara\n\n\n3\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[, -1]\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\nMontes de Oca\nSan Rafael\n\n\nNicoya\nNosara\n\n\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[-1, -1]\n\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\n2\nNicoya\nNosara\n\n\n3\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[,\"provincia\"]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCódigo\ndf[,c(\"provincia\", \"canton\")]\n\n\n\n\n\n\nprovincia\ncanton\n\n\n\n\nSan José\nMontes de Oca\n\n\nGuanacaste\nNicoya\n\n\nGuanacaste\nLiberia\n\n\n\n\n\n\n \nLas listas requieren 1 índice entre dobles corchetes [[índice]]:\n\n\nCódigo\nl &lt;- list(c(\"a\", \"b\"),\n          c(1, 2, 3),\n          c(FALSE, TRUE, FALSE, FALSE))\n\nl[[1]]\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nl[[3]]\n\n\n[1] FALSE  TRUE FALSE FALSE\n\n\n \nLos elementos dentro de las listas también pueden ser subconjuntos en la misma cadena de código:\n\n\nCódigo\nl[[1]][1:2]\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nl[[3]][2]\n\n\n[1] TRUE"
  },
  {
    "objectID": "fundamentos_de_r.html#explorar-objectos",
    "href": "fundamentos_de_r.html#explorar-objectos",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.2 Explorar objectos",
    "text": "4.2 Explorar objectos\nLas siguientes funciones de R básico (predeterminadas) nos pueden ayudar a explorar la estructura de los objetos:\n\n\nCódigo\nstr(df)\n\n\n'data.frame':   3 obs. of  3 variables:\n $ provincia: chr  \"San José\" \"Guanacaste\" \"Guanacaste\"\n $ canton   : chr  \"Montes de Oca\" \"Nicoya\" \"Liberia\"\n $ distrito : chr  \"San Rafael\" \"Nosara\" \"Nacascolo\"\n\n\nCódigo\nnames(df)\n\n\n[1] \"provincia\" \"canton\"    \"distrito\" \n\n\nCódigo\ndim(df)\n\n\n[1] 3 3\n\n\nCódigo\nnrow(df)\n\n\n[1] 3\n\n\nCódigo\nncol(df)\n\n\n[1] 3\n\n\nCódigo\nhead(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ntail(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ntable(df$provincia)\n\n\n\nGuanacaste   San José \n         2          1 \n\n\nCódigo\nclass(df)\n\n\n[1] \"data.frame\"\n\n\n\n\nCódigo\nView(df)"
  },
  {
    "objectID": "fundamentos_de_r.html#ejercicio-3",
    "href": "fundamentos_de_r.html#ejercicio-3",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.3 Ejercicio 3",
    "text": "4.3 Ejercicio 3\n \n\nUtilice los datos de ejemplo iris para crear un subconjunto de datos con sólo las observaciones de la especie setosa\nAhora cree un subconjunto de datos que contenga las observaciones tanto de “setosa” como de “versicolor”\nTambién con iris cree un subconjunto de datos con las observaciones para las que iris$Sepal.length es mayor que 6\n¿Cuántas observaciones tienen una longitud de sépalo superior a 6?"
  },
  {
    "objectID": "fundamentos_de_r.html#section-1",
    "href": "fundamentos_de_r.html#section-1",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.4  ",
    "text": "4.4"
  },
  {
    "objectID": "fundamentos_de_r.html#nombres-de-archivos",
    "href": "fundamentos_de_r.html#nombres-de-archivos",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.1 Nombres de archivos",
    "text": "5.1 Nombres de archivos\nLos nombres de los archivos deben terminar en .R y, por supuesto, ser auto-explicatorios:\n\nBien: graficar_probabilidad_posterior.R\nMal: graf.R"
  },
  {
    "objectID": "fundamentos_de_r.html#nombres-de-objetos",
    "href": "fundamentos_de_r.html#nombres-de-objetos",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.2 Nombres de objetos",
    "text": "5.2 Nombres de objetos\nVariables y funciones:\n\nMinúsculas\nUtilice un guión bajo\nEn general, nombres para las variables y verbos para las funciones\nProcure que los nombres sean concisos y significativos (no siempre es fácil)\nAvoid using names of existing functions of variables\n\n\n\nCódigo\n  - Bien: dia_uno: dia_1, peso_promedio(),\n  \n  - Mal: diauno, dia1, primer.dia_delmes"
  },
  {
    "objectID": "fundamentos_de_r.html#syntaxis",
    "href": "fundamentos_de_r.html#syntaxis",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.3 Syntaxis",
    "text": "5.3 Syntaxis\n\n5.3.1 Espacios\n\nUtilice espacios alrededor de los operadores y para los argumentos dentro de una función\nPonga siempre un espacio después de una coma, y nunca antes (como en el inglés normal)\nColoque un espacio antes del paréntesis izquierdo, excepto en una llamada a una función\n\n\n\nCódigo\n  - Bien: \n          a &lt;- rnorm(n = 10, sd = 10, mean = 1)\n          total &lt;- sum(x[1, ])\n\n  - Mal: \n         a&lt;-rnorm(n=10,sd=10,mean=1) \n         total &lt;- sum(x[,1])  \n\n\n \n\n5.3.1.1 Corchetes\n\nLa llave de apertura nunca debe ir en su propia línea\nLa llave de cierre debe ir siempre en su propia línea\nPuede omitir las llaves cuando un bloque consiste en una sola declaración\n\n\n\nCódigo\n  - Bien:\n              if (is.null(ylim)) {\n              ylim &lt;- c(0, 0.06)\n            }\n                      \n            if (is.null(ylim))\n              ylim &lt;- c(0, 0.06)\n          \n  - Mal:\n            \n         if (is.null(ylim)) ylim &lt;- c(0, 0.06)\n                    \n         if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} \n\n         if (is.null(ylim)) {\n           ylim &lt;- c(0, 0.06)\n           } \n\n\n \n\n\n5.3.1.2 Crear objetos\n\nUse &lt;-, no =\n\n\n\nCódigo\n  - Bien:\n         x &lt;- 5 \n          \n  - Mal:\n         x = 5\n\n\n \n\n\n5.3.1.3 Sugerencias para añadir comentarios\n\nComente su código\nLas líneas enteras comentadas deben comenzar con # y un espacio\nLos comentarios cortos pueden colocarse después del código precedido por dos espacios, #, y luego un espacio\n\n\n\nCódigo\n# Crear un histograma del numero de individuos por unidad de tiempo\nhist(df$pct.spent,\n     breaks = \"scott\",  # method for choosing number of buckets\n     main   = \"Histograma: individuos por unidad de tiempo\",\n     xlab   = \"Número de individuos\",\n     ylab   = \"Frecuencia\")\n\n\n \n\n\n5.3.1.4 Disposición general y ordenación (estilo de google)\n\nComentario de la declaración de derechos de autor (?)\nComentario del autor\nComentario de la descripción del archivo, incluyendo el propósito del programa, las entradas y las salidas\ndeclaraciones source() y library()\nDefiniciones de funciones\nSentencias ejecutadas, si procede (por ejemplo, print, plot)"
  },
  {
    "objectID": "fundamentos_de_r.html#package-documentation",
    "href": "fundamentos_de_r.html#package-documentation",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.1 Package documentation",
    "text": "6.1 Package documentation\n\n \nReference manuals\nLos manuales de referencia son colecciones de la documentación de todas las funciones de un paquete (sólo 1 por paquete):\n\nmanual de dynaSpec\nmanual de baRulho"
  },
  {
    "objectID": "fundamentos_de_r.html#documentación-de-las-funciones",
    "href": "fundamentos_de_r.html#documentación-de-las-funciones",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.2 Documentación de las funciones",
    "text": "6.2 Documentación de las funciones\nTodas las funciones (por defecto o de paquetes cargados) deben tener una documentación que siga un formato estándar:\n\n\nCódigo\n?mean\n\nhelp(\"mean\")\n\n\n\nEsta documentación también puede mostrarse en Rstudio pulsando F1 cuando el cursor está en el nombre de la función\n \nSi no recuerda el nombre de la función pruebe con apropos():\n\n\nCódigo\napropos(\"mean\")\n\n\n [1] \".colMeans\"      \".rowMeans\"      \"circadian.mean\" \"circular.mean\" \n [5] \"colMeans\"       \"geometric.mean\" \"harmonic.mean\"  \"kmeans\"        \n [9] \"mean\"           \"mean.Date\"      \"mean.default\"   \"mean.difftime\" \n[13] \"mean.POSIXct\"   \"mean.POSIXlt\"   \"rowMeans\"       \"weighted.mean\" \n[17] \"winsor.mean\"    \"winsor.means\""
  },
  {
    "objectID": "fundamentos_de_r.html#viñetas-vignettes",
    "href": "fundamentos_de_r.html#viñetas-vignettes",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.3 Viñetas (vignettes)",
    "text": "6.3 Viñetas (vignettes)\nLas viñetas son documentos ilustrativos o casos de estudio que detallan el uso de un paquete (opcional, pueden ser varios por paquete).\nLas viñetas se pueden llamar directamente desde R:\n\n\nCódigo\nvgn &lt;- browseVignettes() \n\n\n\n\nCódigo\nvignette()\n\n\nTambién deberían aparecer en la página del paquete en CRAN."
  },
  {
    "objectID": "fundamentos_de_r.html#demonstraciones",
    "href": "fundamentos_de_r.html#demonstraciones",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.4 Demonstraciones",
    "text": "6.4 Demonstraciones\nLos paquetes también pueden incluir demostraciones de código extendidas (“demos”). Para listar las demos de un paquete ejecute demo(\"nombre del paquete\"):\n\n\nCódigo\ndemo(package=\"stats\")\n\n# call demo directly\ndemo(\"nlm\")"
  },
  {
    "objectID": "fundamentos_de_r.html#ejercicio-4",
    "href": "fundamentos_de_r.html#ejercicio-4",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.5 Ejercicio 4",
    "text": "6.5 Ejercicio 4\n \n\n¿Qué hace la función cut()?\n¿Para qué se utiliza el argumento breaks en cut()?\nEjecuta las 4 primeras líneas de código de los ejemplos proporcionados en la documentación de cut().\n¿Cuántas viñetas tiene el paquete warbleR?"
  },
  {
    "objectID": "fundamentos_de_r.html#referencias",
    "href": "fundamentos_de_r.html#referencias",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.6 Referencias",
    "text": "6.6 Referencias\n\nAdvanced R, H Wickham\nGoogle’s R Style Guide\n\nHands-On Programming with R (Grolemund, 2014)\n\n\nInformación de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] psych_2.4.6.26\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-165      svglite_2.1.3     cli_3.6.3        \n [5] knitr_1.48        rlang_1.1.4       xfun_0.47         stringi_1.8.4    \n [9] highr_0.11        jsonlite_1.8.8    glue_1.7.0        colorspace_2.1-1 \n[13] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.28    grid_4.4.1       \n[17] evaluate_0.24.0   munsell_0.5.1     kableExtra_1.4.0  fastmap_1.2.0    \n[21] yaml_2.3.10       lifecycle_1.0.4   stringr_1.5.1     compiler_4.4.1   \n[25] htmlwidgets_1.6.4 rstudioapi_0.16.0 lattice_0.22-6    systemfonts_1.1.0\n[29] digest_0.6.37     viridisLite_0.4.2 R6_2.5.1          parallel_4.4.1   \n[33] mnormt_2.1.1      magrittr_2.0.3    tools_4.4.1       xml2_1.3.6"
  },
  {
    "objectID": "bucles.html",
    "href": "bucles.html",
    "title": "Bucles",
    "section": "",
    "text": "Aprender a aplicar de forma serial operaciones que deben repetirse sobre diferentes objetos\nFamiliarizarse con el uso de bucles en la plataforma R\nTener una noción general de los opciones disponibles en R para construir bucles\nPrimero debemos preparar los archivos de ejemplo:\nCódigo\n# definir directorio a donde guardar los archivos\ndirectorio &lt;- \"DIRECCION_DONDE_GUARDAR_LOS ARCHIVOS_DE_EJEMPLO\"\n\n# guardar archivos\ndownload.file(\n  url = paste0(\n    \"https://github.com/maRce10/ucr_r_avanzado/\",\n    \"raw/master/additional_files/datos_camara_submarina.zip\"\n  ),\n  destfile = file.path(directorio, \"datos_camara_submarina.zip\")\n)\n\n# extraerlos del zip\nunzip(\n  zipfile = file.path(directorio, \"datos_camara_submarina.zip\"),\n  exdir = directorio\n)\n\n# hacer vector con nombre y direccion de archivos\narchivos_txt &lt;-\n  list.files(\n    path = directorio,\n    full.names = TRUE,\n    pattern = \"TXT$\"\n  )\nTambién pueden bajar el archivo directamente de este enlance. Recuerde extraer los archivos y hacer el vector con los nombres de los archivos (correr lineas de la 9 a la 13).\nSi todo salió bien el vector “archivos_txt” deberia tener 19 elementos:\nCódigo\nlength(archivos_txt)\n\n\n[1] 19"
  },
  {
    "objectID": "bucles.html#aplicación-al-manejo-de-datos",
    "href": "bucles.html#aplicación-al-manejo-de-datos",
    "title": "Bucles",
    "section": "2.1 Aplicación al manejo de datos",
    "text": "2.1 Aplicación al manejo de datos\nUsaremos los datos de ejemplo que bajamos al inicio del manual para demostrar la utilidad del los bucles en el manejo de datos. Estos datos muestran la salida de un programa de identificación automática de especies marinas en videos pasivos tomados en la columna de agua. Para cada video analizado el programa genera un archivo de texto (.TXT) con una fila para cada especie detectada mas una serie de metadatos asociados a la detección. Los datos se ven así:\n\n\n\n\n\n\n\n\n\n \nRecordemos que los nombres de los archivos .TXT están guardados en un vector llamado archivos_txt. Podemos leer el primer archivo (i.e. el primer elemento en archivos_txt) de la siguiente forma:\n\n\nCódigo\narchivo1 &lt;-\n  read.table(archivos_txt[1],\n             header = TRUE,\n             skip = 4,\n             sep = \"\\t\")\n\n# ver pirmeras 4 filas y 8 columnas\nhead(archivo1[1:4, 1:8])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFilename\nFrame\nTime..mins.\nPeriod\nPeriod.time..mins.\nOpCode\nTapeReader\nDepth\n\n\n\n\nGH018767_LcamT3.MP4\n11451\n3.1840\ninicio\n1.5504\nR3-LcamT3-RcamN4_Pelada1_2021-09-24\nAndres\n10\n\n\nGH018767_LcamT3.MP4\n25005\n6.9528\ninicio\n5.3192\nR3-LcamT3-RcamN4_Pelada1_2021-09-24\nAndres\n10\n\n\nGH028767_LcamT3.MP4\n30464\n24.5201\ninicio\n22.8865\nR3-LcamT3-RcamN4_Pelada1_2021-09-24\nAndres\n10\n\n\nGH018767_LcamT3.MP4\n26911\n7.4828\ninicio\n5.8492\nR3-LcamT3-RcamN4_Pelada1_2021-09-24\nAndres\n10\n\n\n\n\n\n\n \nPodemos saber cuantas especies se observaron en ese muestreo simplemente calculado el número de filas en archivo:\n\n\nCódigo\nnrow(archivo1)\n\n\n[1] 39\n\n\n \nAhora, para hacer esto con todos los archivos no es eficiente leer cada uno en su propia linea de código y luego calcular el número de filas. Al fin de cuentas, todos los códigos serian muy parecidos, solo cambiaría el nombre del archivo. Es en estos casos que los bucles son de gran utilidad. En este ejemplo solo debemos incorporar el código de lectura del archivo y del cálculo del número de filas en el cuerpo del bucle, usando el nombre de los archivos (archivos_txt) como el vector sobre el cual iterar el bucle:\n\n\nCódigo\n# vector vacio\nresultados &lt;- vector()\n\n# inicio del bucle\nfor (i in archivos_txt) {\n  # leer archivo\n  txt &lt;- read.table(i,\n                    header = TRUE,\n                    skip = 4,\n                    sep = \"\\t\")\n  # calcular numero de filas\n  n_sp &lt;- nrow(txt)\n  \n  # guardar resultados en vector vacio\n  resultados &lt;- append(resultados, n_sp)\n}\n\nresultados\n\n\n [1] 39  1  2 12 14  9 12  8 32 36 21 12 22 27 29 19  8 12 26\n\n\n \nPodemos ordenar estos resultados fácilmente haciendo un cuadro de datos (data.frame). Para esto creamos una columna con el nombre del archivo y otra con el resultado del número de filas:\n\n\nCódigo\n# organizar en data frame\nn_sp_df &lt;-\n  data.frame(archivo = basename(archivos_txt), \n             n_sp = resultados)\n\n# ver primeras 6 filas\nhead(n_sp_df)\n\n\n\n\n\n\narchivo\nn_sp\n\n\n\n\n2022-09-02_R3-LcamT3-RcamN4_Pel1_2021-09-24_MaxN.TXT\n39\n\n\n2022-09-03_S6-LB13-RB12_PuntaMariaOeste_2022-03-24_MaxN.TXT\n1\n\n\n2022-09-03_T4-LB19-RB18_PuntaMariaOeste_2022-03-24_MaxN.TXT\n2\n\n\n2022-09-04_S1-LB10-RN9_Arco2_2022-07-15_MaxN.TXT\n12\n\n\n2022-09-07_P1-LB12-RB13_Gissler_2022-03-30_MaxN.TXT\n14\n\n\n2022-09-11_P1-LB14-RB13_Risco_2022-03-26_MaxN.TXT\n9\n\n\n\n\n\n\n\n Ejercicio 1 \n \nPodemos calcular el número de familias observadas para el primer archivo que leímos (archivo1) de esta forma:\n\n\nCódigo\nlength(unique(archivo1$Family))\n\n\n[1] 19\n\n\n1.1 Haga un bucle for que devuelva el número de familias para cada archivo\n \n1.2 Cree un cuadro de datos (data frame) que contenga dos columnas, una para el nombre del archivo y otra para el número de familias\n\n\nCódigo\nn_familias_df &lt;-\n  data.frame(archivo = basename(archivos_txt), \n             n_familias = resultados)\n\n\n \n1.3 Añada una columna al cuadro de datos creado en el ejercicio anterior indicando la fecha de creación del video (esta información se encuentra en la columna ‘Date’ de cada archivo de texto). Note que cada archivo contiene solamente una fecha. Debe usar un bucle for para extraer esta información de los archivos.\n \n1.4 Añada una columna al cuadro de datos creado en el ejercicio 1.2 (y modificado en 1.3) indicando la profundidad a la que se grabó el video. Debe usar un bucle for para extraer esta información de los archivos.\n \nPuede usar el siguiente código para convertir profundidad a un vector numérico:\n\n\nCódigo\nn_sp_df$profundidad &lt;-\n  as.numeric(gsub(\" m\", \"\", gsub(\"\\\\,\", \n                                 \".\", \n                                 n_sp_df$profundidad)))\n\n\n1.5 ¿Cuál es la correlación entre el número de especies observadas (que es igual al número de filas) y la profundidad? (pista: cor.test())\n \n1.6 ¿Cuál es la correlación entre el número de familias y la profundidad?\n \n\nEl bucle for también puede ser usado para juntar todas los datos de los archivos de texto en un solo cuadro de datos. Esto lo podemos hacer “rellenando” un cuadro de datos vacío, de forma análoga a como rellenamos un vector vació anteriormente:\n\n\nCódigo\n# vector vacio\ndf_resultados &lt;- data.frame()\n\n# inicio del bucle\nfor (i in archivos_txt) {\n  # leer archivo\n  txt &lt;- read.table(i,\n                    header = TRUE,\n                    skip = 4,\n                    sep = \"\\t\")\n  \n  # guardar resultados en vector vacio\n  df_resultados &lt;- rbind(df_resultados, txt)\n}\n\nnrow(df_resultados) == sum(n_sp_df$filas)\n\n\n[1] FALSE"
  },
  {
    "objectID": "bucles.html#bucles-replicate",
    "href": "bucles.html#bucles-replicate",
    "title": "Bucles",
    "section": "3.1 bucles replicate",
    "text": "3.1 bucles replicate\nEl bucle replicate también pertenece a la familia de los (X)apply (a pesar de su nombre), ya que toma una función y la replica. Sin embargo solo replica una acción (generalmente aleatoria) y el usuario no tiene control sobre el insumo a la función. El argumento ‘n’ define cuantas veces se replica la acción y ‘expr’ define la acción a realizar:\n\n\nCódigo\nreplicate(n = 3, expr = rnorm(10))\n\n\n           [,1]      [,2]     [,3]\n [1,]  0.076771 -0.464891 -0.98506\n [2,]  0.459076 -1.471384  1.66499\n [3,]  0.617080  0.258940  0.78420\n [4,]  0.507372  0.336526  0.51279\n [5,] -0.323608 -0.634438 -0.18349\n [6,] -0.139401 -0.508982  1.13750\n [7,] -0.257033 -0.081415  1.32404\n [8,] -0.508473  0.807334  0.48490\n [9,] -0.852319 -0.361514  0.59964\n[10,]  1.107557 -1.131815  0.19271\n\n\n \nNote que los resultados son agrupados en una matrix. ‘expr’ también puede replicar código que no ha sido “empaquetado en una función”.\n \n\n Ejercicio 2\n \n2.1 Haga un bucle lapply equivalente al bucle for en el ejercicio 1.1.\n \n2.2 Haga un bucle sapply equivalente al bucle for en el ejercicio 1.1 y ponga el resultado en un cuadro de datos, similiar a lo hecho en el ejercicio 1.2\n \n2.3 Haga un bucle sapply que permita añadir al cuadro de datos creado en el ejercicio anterior el total de individuos observados en un muestreo (pista: sumatoria de la columna ‘MaxN’).\n \n2.4 Haga un bucle tapply para calcular el error estandar para el ancho de sépalo por especie en el juego de datos ‘iris’."
  },
  {
    "objectID": "bucles.html#referencias",
    "href": "bucles.html#referencias",
    "title": "Bucles",
    "section": "5.1 Referencias",
    "text": "5.1 Referencias\n\nAdvanced R, H Wickham\nA Tutorial on Loops in R - Usage and Alternatives, DataCamp\n\n\nSession information\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] RColorBrewer_1.1-3 ggplot2_3.5.1     \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       cli_3.6.3         knitr_1.48        rlang_1.1.4      \n [5] xfun_0.47         generics_0.1.3    jsonlite_1.8.8    labeling_0.4.3   \n [9] glue_1.7.0        colorspace_2.1-1  htmltools_0.5.8.1 scales_1.3.0     \n[13] fansi_1.0.6       rmarkdown_2.28    grid_4.4.1        evaluate_0.24.0  \n[17] munsell_0.5.1     tibble_3.2.1      fastmap_1.2.0     yaml_2.3.10      \n[21] lifecycle_1.0.4   compiler_4.4.1    dplyr_1.1.4       htmlwidgets_1.6.4\n[25] pkgconfig_2.0.3   rstudioapi_0.16.0 farver_2.1.2      digest_0.6.37    \n[29] R6_2.5.1          tidyselect_1.2.1  utf8_1.2.4        pillar_1.9.0     \n[33] magrittr_2.0.3    withr_3.0.1       tools_4.4.1       gtable_0.3.5"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\nProgramación y métodos estadísticos avanzados en R\n",
    "section": "",
    "text": "Escuela de Biología, Universidad de Costa Rica\n\n\nMarcelo Araya-Salas PhD y  Mario Espinoza PhD\n\nEste curso pretende profundizar en los elementos de programación computacional, manipulación de bases de datos, diseño experimental, graficación personalizada, y el uso de técnicas y modelaje estadístico avanzadas utilizando R como plataforma. El curso está dirigido a estudiantes avanzados de carrera, de licenciatura o postgrado. En el curso se pretende cubrir las bases de los principales análisis y técnicas de modelaje estadístico, así como análisis emergentes. Las clases mezclan las explicaciones teóricas con prácticas en donde se aplican los conceptos desarrollados . Además, durante el curso cada estudiante presentará un paquete o extensión (conjunto de herramientas aplicables a análisis específicos) de R, en donde profundizará sobre sus aplicaciones en el campo de la biología demostrando en clase en que consiste el análisis.\n \n\nObjetivos\n\nFamiliarizar al estudiante con la programación en R\nBrindar herramientas para la manipulación de bases de datos\nEmplear métodos de visualización de datos\nCubrir algunos de los análisis estadísticos tradicionales\nProveer a los estudiantes con experiencia en la aplicación de las herramientas brindadas por medio de prácticas y proyectos de investigación\n\n\n \n\nDinámica de las clases\n\nPueden hacer preguntas en cualquier momento\nSientanse libres de responder preguntas de compañeros\nTraten siempre de correr el código y de entender todos sus elementos\nLas líneas de código estan numeradas. Podemos usar esos números para referirnos a códigos específicos en los manuales. Los bloques de código también incluyen un botón que permite copiar el código:\n\n\n\n\n\n\n\n\n\n\n\nTambién usaremos el enlace “Compartir código” en el menú principal de este sitio (arriba) para pasar códigos que se desarrollen en clase\n\n \n\nConsejos para garantizar el máximo aprovechamiento del curso\n\nAseguráte de tener todo lo que necesitas antes del comienzo de la clase\nTratá de estar preparado unos minutos antes del comienzo de la clase\nIntenta concentrarte al máximo en el curso, cierra otros programas o pestañas innecesarias del navegador de internet (por ejemplo, instagram, twitter, etc)\nComentá el código"
  },
  {
    "objectID": "funciones.html",
    "href": "funciones.html",
    "title": "Funciones",
    "section": "",
    "text": "Identificar los elementos básicos que componen una función\nComprender las características de los principales tipos de argumentos en las funciones\nSer capaz de construir funciones propias"
  },
  {
    "objectID": "funciones.html#nombre",
    "href": "funciones.html#nombre",
    "title": "Funciones",
    "section": "3.1 Nombre",
    "text": "3.1 Nombre\n\n\n\n\n\n\n\n\n\nLos nombres de las funciones tienen pocas restricciones. Siguen las mismas reglas que otros objetos en R. Algunas recomendaciones/reglas:\n\nNo utilice nombres de objetos comunes R (por ejemplo, iris, x) u objetos que ya están en el entorno\nNo use nombres de funciones de uso frecuente (por ejemplo, mean)\nNo puede comenzar con un número\nDebería sugerir lo que hace\nNo debe ser muy largo\n\nEn caso de que tenga varias funciones con el mismo nombre, puede llamarlas individualmente utilizando el nombre del paquete (o namespace) seguido de :::\n\n\nCódigo\n# crear funcion sd\nsd &lt;- function(x) x^10\n\n# no calcula desv. st.\nsd(1:5)\n\n\n[1]       1    1024   59049 1048576 9765625\n\n\nCódigo\n# sd\nstats::sd(1:5)\n\n\n[1] 1.5811\n\n\nCódigo\n# remover nueva sd\nrm(sd)\n\n# usar de nuevo\nsd(1:5)\n\n\n[1] 1.5811\n\n\n \nLa sintaxis namespace::function también se puede usar para llamar a funciones desde paquetes que se han instalado pero que no están cargados en el entorno actual.\n \nLas funciones pueden ser anónimas:\n\n\nCódigo\n(function(x) x^10)(1:5)\n\n\n[1]       1    1024   59049 1048576 9765625\n\n\n \nEsto es más útil cuando se usan las funciones Xapply:\n\n\nCódigo\nl &lt;- list(1:5, 1:4, 1:3)\n\nlapply(l, function(x) x^10)\n\n\n[[1]]\n[1]       1    1024   59049 1048576 9765625\n\n[[2]]\n[1]       1    1024   59049 1048576\n\n[[3]]\n[1]     1  1024 59049"
  },
  {
    "objectID": "funciones.html#argumentos",
    "href": "funciones.html#argumentos",
    "title": "Funciones",
    "section": "3.2 Argumentos",
    "text": "3.2 Argumentos\n\n\n\n\n\n\n\n\n\n \nPermiten a los usuarios ingresar objetos en la función. Los argumentos pueden o no tener valores predeterminados. Cuando los argumentos tienen valores predeterminados, no es necesario proporcionarlos:\n\n\nCódigo\nf1 &lt;- function(x, y = 2) x + y\n\nf1(1)\n\n\n[1] 3\n\n\n \nPor supuesto, se pueden modificar:\n\n\nCódigo\nf1(3, 4)\n\n\n[1] 7\n\n\n \nLos argumentos sin valor predeterminado deben ser proporcionados:\n\n\nCódigo\nf1()\n\n\nError in f1(): argument \"x\" is missing, with no default\n\n\n \nSi todos los argumentos tienen un valor predeterminado, se puede invocar la función sin proporcionar ningún argumento:\n\n\nCódigo\nf1 &lt;- function(x = -2, y = 2) x + y\n\nf1()\n\n\n[1] 0\n\n\n \nEse es el caso de dev.off() y Sys.time():\n\n\nCódigo\nSys.time()\n\n\n[1] \"2024-09-30 13:35:31.875 CST\"\n\n\n \nLos argumentos pueden especificarse implícitamente por posición o por nombres incompletos:\n\n\nCódigo\nf2 &lt;- function(a1, b1, b2) {\n  list(a1 = a1, b1 = b1, b2 = b2)\n}\n\n# por posicion\nstr(f2(1, 2, 3))\n\n\nList of 3\n $ a1: num 1\n $ b1: num 2\n $ b2: num 3\n\n\nCódigo\n# por posicion y nombre\nstr(f2(a = 1, 2, 3))\n\n\nList of 3\n $ a1: num 1\n $ b1: num 2\n $ b2: num 3\n\n\nCódigo\nstr(f2(1, a = 2, 3))\n\n\nList of 3\n $ a1: num 2\n $ b1: num 1\n $ b2: num 3\n\n\nCódigo\nstr(f2(1, 2, a = 3))\n\n\nList of 3\n $ a1: num 3\n $ b1: num 1\n $ b2: num 2\n\n\nCódigo\n# por posicion y nombre parcial\nstr(f2(1, a = 2, b1 = 3))\n\n\nList of 3\n $ a1: num 2\n $ b1: num 3\n $ b2: num 1\n\n\n \nSin embargo, esto no funciona si los nombres son ambiguos:\n\n\nCódigo\nf2(b = 1, 2, a = 3)\n\n\nError in f2(b = 1, 2, a = 3): argument 1 matches multiple formal arguments\n\n\n \nEs más seguro (y, por lo tanto, una mejor práctica) usar los nombres completos de los argumentos.\n \nLas funciones también pueden tomar argumentos lógicos. Estos son útiles para modificar el comportamiento de la función para que coincida con diferentes escenarios. Por ejemplo, mean() permite a los usuarios ignorar los NA:\n\n\nCódigo\nv1 &lt;- c(1, 2, 3, NA)\n\n# sin ignorar NAs\nmean(v1, na.rm = FALSE)\n\n\n[1] NA\n\n\nCódigo\n# ignorando NAs\nmean(v1, na.rm = TRUE)\n\n\n[1] 2"
  },
  {
    "objectID": "funciones.html#ejercicio-1",
    "href": "funciones.html#ejercicio-1",
    "title": "Funciones",
    "section": "3.3 Ejercicio 1",
    "text": "3.3 Ejercicio 1\n1.1 ¿Qué hace la función cor.test()?\n1.2 Úsela con “Sepal.Length” y “Sepal.Width” de los datos de ejemplo iris (use data(iris))\n1.3 ¿Qué argumentos deben proporcionarse?\n1.4 ¿Qué hace el argumento alternative? Use diferentes valores para este argumento y compare los resultados\n1.5 ¿Cómo se puede calcular la correlación de Spearman?\n1.6 ¿Qué tipo de objeto devuelve esta función?\n1.7 ¿Cómo puede obtener el valor de p directamente del resultado de la función (sin guardar el resultado como un objeto)?\n1.8 Escoga una función de R y lea su documentación con el fin de entender su uso, cada uno de sus argumentos (y que tipo de objetos requieren) y el resultado que produce (es probable que se le pida que explique esto al grupo)"
  },
  {
    "objectID": "funciones.html#cuerpo",
    "href": "funciones.html#cuerpo",
    "title": "Funciones",
    "section": "3.4 Cuerpo",
    "text": "3.4 Cuerpo\n\n\n\n\n\n\n\n\n\nEl cuerpo de una función puede contener:\n\nComprobación de argumentos\nManipulación de datos\nDefinición de resultados\n\n \nEl cuerpo de la función puede tomar el mismo tipo de código utilizado en cualquier rutina de R. Sin embargo, los objetos creados no estarán disponibles en el entorno.\nCuando se realizan varios cálculos, debemos incluir una declaración de retorno (return statement), que define explícitamente la salida de la función. Esto se hace usando la función return():\n\n\nCódigo\n# sin \"return statement\"\nf1 &lt;- function(x, y) {\n  z1 &lt;- 2 * x + y\n  z2 &lt;- x + 2 * y\n  z3 &lt;- 2 * x + 2 * y\n  z4 &lt;- x / y\n}\n\nf1(5, 3)\n\nf1_out &lt;- f1(5, 3)\n\nf1_out\n\n\n[1] 1.6667\n\n\nCódigo\n# con \"return statement\"\nf2 &lt;- function(x, y) {\n  z1 &lt;- 2 * x + y\n  z2 &lt;- x + 2 * y\n  z3 &lt;- 2 * x + 2 * y\n  z4 &lt;- x / y\n\n  return(c(z1, z2, z3, z4))\n}\n\nf2(5, 3)\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\nCódigo\nf2_out &lt;- f2(5, 3)\n\nf2_out\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\n \nPor lo tanto, cuando no se proporciona una declaración de retorno, la función devolverá el último objeto que se creó en el cuerpo de la función:\n\n\nCódigo\n# sin \"return statement\"\nf3 &lt;- function(x, y) {\n  z1 &lt;- 2 * x + y\n  z2 &lt;- x + 2 * y\n  z3 &lt;- 2 * x + 2 * y\n  z4 &lt;- x / y\n\n  c(z1, z2, z3, z4)\n}\n\nf3(5, 3)\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\nCódigo\nf3_out &lt;- f3(5, 3)\n\nf3_out\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\n \nEs más seguro usar return().\n \nCuando una función realiza varias tareas, podemos usar una lista para juntar los diferentes objetos. Esto es particularmente útil cuando se generan objetos de diferentes clases (por ejemplo, vectores y listas):\n\n\nCódigo\nf4 &lt;- function(x, y) {\n  # 1 elemento\n  z1 &lt;- x + y\n\n  # 2 elementos\n  z2 &lt;- c(x, y / 3)\n\n  # vector logico\n  z3 &lt;- z2 &lt; 10\n\n\n  l &lt;- list(z1, z2, z3)\n\n  return(l)\n}\n\nf4(10, 5)\n\n\n[[1]]\n[1] 15\n\n[[2]]\n[1] 10.0000  1.6667\n\n[[3]]\n[1] FALSE  TRUE\n\n\n \nPodemos acceder a elementos específicos de la salida de una función mediante indexación:\n\n\nCódigo\n# elemento 1\nf4(10, 5)[[1]]\n\n\n[1] 15\n\n\nCódigo\n# elemento 2\nf4(10, 5)[[2]]\n\n\n[1] 10.0000  1.6667\n\n\nCódigo\n# elemento 3\nf4(10, 5)[[3]]\n\n\n[1] FALSE  TRUE\n\n\n \nPor supuesto, también podemos guardar el resultado como un objeto y acceder a cada elemento mediante la indexación:\n\n\nCódigo\n# elemento 1\nout &lt;- f4(10, 5)\n\n# elemento 1\nout[[1]]\n\n\n[1] 15\n\n\nCódigo\n# elemento 2\nout[[2]]\n\n\n[1] 10.0000  1.6667"
  },
  {
    "objectID": "funciones.html#ejercicio-2",
    "href": "funciones.html#ejercicio-2",
    "title": "Funciones",
    "section": "2.5 Ejercicio 2",
    "text": "2.5 Ejercicio 2\n2.1 Cree una función llamada promedio que calcule el promedio de un vector numérico. Internamente solo puede utilizar las funciones sum() y length() (suma y división, no puede llamar la función mean())\n2.2 Cree una función que tome 2 argumentos numéricos (llámelos ‘x’ y ‘y’), eleve cada uno al cuadrado y luego los sume\n2.3 Agregue valores predeterminados a cada argumento\n2.4 Ejecute la función usando los valores predeterminados\n2.5 Ejecute la función usando un valor predeterminado y uno proporcionado en la llamada\n2.6 Ejecute la función proporcionando ambos valores en la llamada"
  },
  {
    "objectID": "funciones.html#ejercicio-3",
    "href": "funciones.html#ejercicio-3",
    "title": "Funciones",
    "section": "4.1 Ejercicio 3",
    "text": "4.1 Ejercicio 3\n3.1 Cree una función que tome 3 argumentos numéricos, multiplíquelos y luego calcule el logaritmo natural del resultado (función log())\n3.2 Agregue valores predeterminados a cada argumento\n3.3 Ejecute la función con uno de los argumentos con un número negativo. ¿Qué pasa? ¿Por qué?\n3.4 Agregue un argumento lógico que permita a los usuarios (si lo desean) convertir los argumentos de entrada a su valor absoluto (usando la función abs()). Agregue las modificaciones necesarias para que la función haga los cálculos con y sin valores absolutos."
  },
  {
    "objectID": "funciones.html#código-mas-limpio",
    "href": "funciones.html#código-mas-limpio",
    "title": "Funciones",
    "section": "5.1 Código mas limpio",
    "text": "5.1 Código mas limpio\nLos objetos creados dentro del cuerpo no están disponibles en el entorno actual:\n\n\nCódigo\n# primero remover todo los objetos\nrm(list = ls())\n\nf5 &lt;- function(x) {\n  sqr &lt;- x * x\n  lg_sqr &lt;- log(x)\n  return(lg_sqr)\n}\n\nf5(7)\n\n\n[1] 1.9459\n\n\nCódigo\nexists(\"sqr\")\n\n\n[1] FALSE\n\n\nCódigo\nexists(\"lg_sqr\")\n\n\n[1] FALSE\n\n\n\n\nCódigo\nx &lt;- 7\nsqr &lt;- x * x\nlg_sqr &lt;- log(x)\n\n\nexists(\"sqr\")\n\n\n[1] TRUE\n\n\nCódigo\nexists(\"lg_sqr\")\n\n\n[1] TRUE"
  },
  {
    "objectID": "funciones.html#facil-de-correr-y-compartir",
    "href": "funciones.html#facil-de-correr-y-compartir",
    "title": "Funciones",
    "section": "5.2 Facil de correr y compartir",
    "text": "5.2 Facil de correr y compartir\nSe pueden invocar funciones desde archivos de R externos sin estar definidas en el código actual con la función source(). En este ejemplo creamos la función fnctn_X:\n\n\nCódigo\nfnctn_X &lt;- function(sq_mt, vctr) {\n  # trasponer matriz y calcular est dev\n  stp1 &lt;- t(sq_mt)\n  stp2 &lt;- vctr * vctr\n\n  # guardar en lista\n  rslt &lt;- list(stp1, stp2)\n  return(rslt)\n}\n\nfnctn_X(sq_mt = cbind(c(1, 2), c(3, 4)), vctr = c(2, 3))\n\n\n[[1]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n[[2]]\n[1] 4 9\n\n\n \nGuarde el código anterior en un archivo R llamado ‘function_X.R’. Ahora la función se puede cargar usando source():\n\n\nCódigo\n# removamosla del ambiente\nrm(fnctn_X)\n\n# cargar funcion\nsource(\"function_X.R\")\n\n# run it\nfnctn_X(sq_mt = cbind(c(1, 2), c(3, 4)), vctr = c(2, 3))\n\n\n\n\n[[1]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n[[2]]\n[1] 4 9\n\n\n \nAdemás, este código se puede compartir fácilmente. Se puede enviar por correo electrónico o publicar en línea. Incluso se puede cargar desde repositorios en línea:\n\n\nCódigo\n# remover objetos\nrm(list = ls())\n\n# revisar si existe en ambiente actual\nexists(\"fnctn_X\")\n\n\n[1] FALSE\n\n\nCódigo\n# cargar desde el internet\nsource(\n  paste0(\n    \"https://raw.githubusercontent.com/maRce10/\",\n    \"r_avanzado_2023/master/data/function_x.r\"\n  )\n)\n\n\n# revisar si existe en ambiente actual\nexists(\"fnctn_X\")\n\n\n[1] TRUE"
  },
  {
    "objectID": "funciones.html#se-aplica-fácilmente-a-nuevos-objetos",
    "href": "funciones.html#se-aplica-fácilmente-a-nuevos-objetos",
    "title": "Funciones",
    "section": "5.3 Se aplica fácilmente a nuevos objetos",
    "text": "5.3 Se aplica fácilmente a nuevos objetos\nEsto ya debería ser obvio a este punto."
  },
  {
    "objectID": "funciones.html#otros-consejos",
    "href": "funciones.html#otros-consejos",
    "title": "Funciones",
    "section": "5.4 Otros consejos",
    "text": "5.4 Otros consejos\n\nConstruir funciones cortas:\n\nFácil de leer\nFácil de arreglar y actualizar\nSi es demasiado largo, probablemente debería dividirse en varias funciones\nGenera modularidad\n\nAñadir comentarios a todo el código  \nAgregar descripciones a cada uno de los argumentos que toma  \nFunción de prueba con diferentes valores/escenarios"
  },
  {
    "objectID": "funciones.html#ejercicio-4",
    "href": "funciones.html#ejercicio-4",
    "title": "Funciones",
    "section": "5.5 Ejercicio 4",
    "text": "5.5 Ejercicio 4\n4.1 Cree una funcion que calcule el promedio, la desviación estándar y el error estándar de un vector numérico. Estos valores deben ser devueltos como una lista con nombres.\n4.2 Permita a los usuarios ignorar los NAs (similar al argumento na.rm en mean(), pista: añada un argumento lógico)\n4.3 Haga que la función además produzca un histograma del vector numérico proporcionado por el usuario\n4.4 Haga que la función permita al usuario defini el color para las barras del histograma\n4.5 Añada un argumento a la función que permita el usuario, si lo desea, calcular la sumatoria (sum()) junto con el resto de los descriptores estadísticos\n4.6 Agregue el promedio y la desviación estándar al título del histograma (pista: use paste())\n4.7 Modifique la función para que también cree una linea vertical indicando el promedio del vector numérico proporcionado por el usuario\n4.8 Modifique la función para que añada un polígono transparente sobre el área que cubre el promedio +/- la desviación estándar (puede usar la función rect())\n4.9 Modifique la función con un argumento lógico que permita al usuario controlar si se crea un gráfico o no"
  },
  {
    "objectID": "funciones.html#lecturas-adicionales",
    "href": "funciones.html#lecturas-adicionales",
    "title": "Funciones",
    "section": "5.6 Lecturas adicionales",
    "text": "5.6 Lecturas adicionales\n\n Introduction to R guide to writing functions with information for a total beginner\nInformation on functions for intermediate and advanced users (Hadley Wickham).\nThe official R intro material on writing your own functions (ir a “Writing your own function”)"
  },
  {
    "objectID": "funciones.html#referencias",
    "href": "funciones.html#referencias",
    "title": "Funciones",
    "section": "5.7 Referencias",
    "text": "5.7 Referencias\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for data science: import, tidy, transform, visualize, and model data. website\n\n\nInformación de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] psych_2.4.6.26\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-165      svglite_2.1.3     cli_3.6.3        \n [5] knitr_1.48        rlang_1.1.4       xfun_0.47         stringi_1.8.4    \n [9] highr_0.11        jsonlite_1.8.8    glue_1.7.0        colorspace_2.1-1 \n[13] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.28    grid_4.4.1       \n[17] evaluate_0.24.0   munsell_0.5.1     kableExtra_1.4.0  fastmap_1.2.0    \n[21] yaml_2.3.10       lifecycle_1.0.4   stringr_1.5.1     compiler_4.4.1   \n[25] htmlwidgets_1.6.4 rstudioapi_0.16.0 lattice_0.22-6    systemfonts_1.1.0\n[29] digest_0.6.37     viridisLite_0.4.2 R6_2.5.1          parallel_4.4.1   \n[33] mnormt_2.1.1      magrittr_2.0.3    tools_4.4.1       xml2_1.3.6"
  },
  {
    "objectID": "preparacion_curso.html",
    "href": "preparacion_curso.html",
    "title": "",
    "section": "",
    "text": "CódigoMostrar todo el códigoOcultar todo el códigoVer el código fuente\n\n\n\n\n\nInstalá R en la computadora que utilizarás durante el curso (https://cran.r-project.org/). Probablemente ya lo tenés instalado, pero intentá actualizarlo si tenés una versión de R &lt; 4.0.0. Podés encontrar qué versión de R tenés ejecutando esto en la consola de R:\n\n\n\nCódigo\nversion$version.string\n\n\n\nInstalá la interfaz de RStudio (https://www.rstudio.com/products/rstudio/download/, elejí la versión gratuita).\nAbrí RStudio y seleccioná la pestaña “Tools” y luego “Global options” (última opción). Seleccioná la opción “Code”, luego seleccioná la casilla de “Soft wrap”.\nTambién en Rstudio: Seleccioná la opción “Pane Layout” y mové “Source” al panel superior izquierdo y “Console” al panel superior derecho. Esta disposición asigna más espacio en la pantalla a los paneles más útiles. Dalé “Apply” y “Ok”. Para aquellos que no estén familiarizados con RStudio, “Source” es un editor de texto donde se escribe el código y donde guardas el código en un archivo físico (normalmente en formato .R) y la consola evalúa el código que se envia desde el “Source” e imprime los resultados (si los hay). Podés escribir código en la consola, pero no se guardará en un archivo físico.\nAhora en la consola de R en Rstudio ejecutá el siguiente código para instalar los paquetes que estaremos usando durante el curso:\n\n\n\nCódigo\n# cargar funcion del paquete \"sketchy\"\nsource(\n  paste0(\n    \"https://raw.githubusercontent.com/maRce10/\",\n    \"sketchy/main/R/load_packages.R\"\n  )\n)\n\n# instalar/ cargar paquetes\nload_packages(\n  packages = c(\n    \"remotes\",\n    \"leaflet\",\n    \"knitr\",\n    \"rmarkdown\",\n    \"kableExtra\",\n    \"RColorBrewer\",\n    \"ggplot2\",\n    \"rmdformats\",\n    \"viridis\",\n    \"revealjs\",\n    \"rticles\",\n    \"tufte\",\n    \"lme4\",\n    \"MASS\",\n    \"lmerTest\",\n    \"sjPlot\",\n    \"car\",\n    github = \"maRce10/sketchy\",\n    github = \"hadley/emo\"\n  )\n)\n\n\n\nCreá un proyecto para el curso corriendo este código:\n\n\n\nCódigo\nlibrary(sketchy)\n\nmake_compendium(\n  name = \"r_avanzado\",\n  path = \"DIRECTORIO_DONDE_HACER_EL_PROYECTO\",\n  Rproj = TRUE,\n  readme = TRUE\n)\n\n\n(en realidad este es tambien un compendio de investigación)\nAbrí el proyecto en Rstudio:\n\nEste proyecto debe usarse cada vez que se trabaja código del curso ✌️"
  },
  {
    "objectID": "respuestas_tarea5.html",
    "href": "respuestas_tarea5.html",
    "title": "Solución a la tarea 5",
    "section": "",
    "text": "Haga un bucle for que una todos los datos contenidos en los archivos de texto en un solo cuadro de datos (‘data frame’, debe llamarse ‘datos_camaras’) y añada una columna con el nombre del archivo de donde provienen los datos (debe llamarse ‘archivo’; pistas: 1) añadir el nombre del archivo en una columna se hace en el cuerpo del bucle luego de leer el archivo; 2) recuerden usar basename()).\n\nRespuesta:\n\n\nCódigo\n# crear un cuadro de datos vacios donde poner los resultados\ndatos_camaras &lt;- data.frame()\n\n# ciclar sobre los archivos para leer los datos\nfor(i in archivos_txt){\n  \n  # leer datos\n  txt &lt;- read.table(i, header = TRUE, skip = 4, sep = \"\\t\")\n  \n  # añadir nombre de archivo\n  txt$archivo &lt;- basename(i)\n  \n  # adjuntar datos\n  datos_camaras &lt;- rbind(datos_camaras, txt) \n}\n\n\n\nHaga un bucle sapply que devuelva el número de familias para cada archivo. El bucle debe usar los datos en el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto). El resultado debe ser guardado en un cuadro de datos (‘data frame’) que contenga las columnas ‘archivo’ y ‘n_familias’. (pistas: 1) necesitan crear una función en la llamada del bucle; 2) el bucle debe ciclar sobre cada uno de los nombres de archivo; 3) deben crear un subconjunto de los datos para cada archivo a lo interno del bucle). Las primeras 3 filas del cuadro de datos deben verse así:\n\n\n\n\n\n\n\n\n\n\n\narchivo\nn_familias\n\n\n\n\n2022-09-02_R3-LcamT3-RcamN4_Pel1_2021-09-24_MaxN.TXT\n19\n\n\n2022-09-03_S6-LB13-RB12_PuntaMariaOeste_2022-03-24_MaxN.TXT\n1\n\n\n2022-09-03_T4-LB19-RB18_PuntaMariaOeste_2022-03-24_MaxN.TXT\n2\n\n\n\n\n\n\nRespuesta:\n\n\nCódigo\n# ciclar sobre los nombres de archivos en datos_camaras$archivo\nn_familias &lt;- sapply(unique(datos_camaras$archivo), function(x){\n  \n  # leer datos de un archivo\n  Y &lt;- datos_camaras[datos_camaras$archivo == x, ]\n  \n  # estimar numero de familias\n  n_fams &lt;- length(unique(Y$Family))\n\n  return(n_fams)\n  })\n\n# guardar resultados en un cuadro de datos\ncam_dat &lt;- data.frame(archivo = basename(unique(datos_camaras$archivo)), n_familias = n_familias, row.names = 1:length(n_familias))\n\n\n\nHaga un bucle sapply que devuelva el número de géneros (columna ‘genus’) para cada archivo. El bucle debe usar los datos en el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto). El resultado debe ser añadido como una nueva columna al cuadro de datos creado en el ejercicio 2. Las primeras 3 filas del cuadro de datos deben verse así:\n\n\n\n\n\n\n\n\n\n\n\n\narchivo\nn_familias\nn_generos\n\n\n\n\n2022-09-02_R3-LcamT3-RcamN4_Pel1_2021-09-24_MaxN.TXT\n19\n32\n\n\n2022-09-03_S6-LB13-RB12_PuntaMariaOeste_2022-03-24_MaxN.TXT\n1\n1\n\n\n2022-09-03_T4-LB19-RB18_PuntaMariaOeste_2022-03-24_MaxN.TXT\n2\n2\n\n\n\n\n\n\nRespuesta:\n\n\nCódigo\n# ciclar sobre los nombres de archivos en datos_camaras$archivo\ncam_dat$n_generos &lt;- sapply(unique(datos_camaras$archivo), function(x){\n  \n   # leer datos de un archivo\n  Y &lt;- datos_camaras[datos_camaras$archivo == x, ]\n  \n  # estimar numero de generos\n  n_gens &lt;- length(unique(Y$Genus))\n\n  return(n_gens)\n  })\n\n\n\nHaga un bucle sapply que devuelva la fecha de creación del video para cada archivo. El bucle debe usar los datos en el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto). El resultado debe ser añadido como una nueva columna al cuadro de datos creado en el ejercicio 2. Las primeras 3 filas del cuadro de datos deben verse así:\n\n\n\n\n\n\n\n\n\n\n\n\n\narchivo\nn_familias\nn_generos\ndate\n\n\n\n\n2022-09-02_R3-LcamT3-RcamN4_Pel1_2021-09-24_MaxN.TXT\n19\n32\n2021-09-25\n\n\n2022-09-03_S6-LB13-RB12_PuntaMariaOeste_2022-03-24_MaxN.TXT\n1\n1\n2022-03-24\n\n\n2022-09-03_T4-LB19-RB18_PuntaMariaOeste_2022-03-24_MaxN.TXT\n2\n2\n2022-03-24\n\n\n\n\n\n\nRespuesta:\n\n\nCódigo\n# ciclar sobre los nombres de archivos en datos_camaras$archivo\ncam_dat$date &lt;- sapply(unique(datos_camaras$archivo), function(x){\n   \n  # leer datos de un archivo\n  Y &lt;- datos_camaras[datos_camaras$archivo == x, ]\n  \n  # extraer fecha\n  date &lt;- length(unique(Y$Date))\n\n  return(date)\n  })\n\n\n\nHaga un bucle sapply que calcule el número de veces que se observó cada especie. El bucle debe trabajar sobre el data frame ‘datos_camaras’ creado en el ejercicio 1 (no debe leer de nuevo los archivos de texto) y el cálculo debe ser la suma de la columna ‘MaxN’. Ponga los resultados en un cuadro de datos con columnas para especie y número de observaciones. (pista: unique(datos_camaras$Species)). Remueva el campo en el que especie es igual a ““. Las primeras 3 filas del cuadro de datos deben verse así:\n\n\n\n\n\n\n\n\nspp\nn_obs\n\n\n\n\nxanthopterus\nxanthopterus\n145\n\n\nlaticlavius\nlaticlavius\n25\n\n\npolylepis\npolylepis\n26\n\n\n\n\n\n\nRespuesta:\n\n\nCódigo\n# ciclar sobre los nombres de archivos en datos_camaras$archivo\nn_obs &lt;- sapply(unique(datos_camaras$Species), function(x){\n  \n  # leer datos de un archivo  \n  X &lt;- datos_camaras[datos_camaras$Species == x, ]\n  \n  # sumar numero de observaciones\n  obs &lt;- sum(X$MaxN)\n  \n  return(obs)\n})\n\n\nsp_dat &lt;- data.frame(spp = unique(datos_camaras$Species), n_obs)\n\nsp_dat &lt;- sp_dat[sp_dat$spp != \"\", ]\n\n\n\nUtilice bucles sapply para añadir el mínimo y máximo de la profundidad para cada una de las especies en el cuadro de datos creado en el ejercicio anterior (pistas: 1) asegúrese que la columna de profundidad es numérica antes de calcular las profundidades; 2) gsub(\" m\", \"\", vector); 3) gsub(\",\", \".\", vector); 4) as.numeric()). Las primeras 3 filas del cuadro de datos deben verse así:\n\n\n\n\n\n\n\n\nspp\nn_obs\nmin_prof\nmax_prof\n\n\n\n\nxanthopterus\nxanthopterus\n145\n6.4\n31.6\n\n\nlaticlavius\nlaticlavius\n25\n9.6\n31.6\n\n\npolylepis\npolylepis\n26\n9.6\n30.0\n\n\n\n\n\n\nRespuesta:\n\n\nCódigo\n# convertir profundidad a una columna numerica\ndatos_camaras$Depth &lt;- gsub(\" m\", \"\", datos_camaras$Depth)\ndatos_camaras$Depth &lt;- gsub(\",\", \".\", datos_camaras$Depth)\ndatos_camaras$Depth &lt;- as.numeric(datos_camaras$Depth)\n\n# ciclar sobre los nombres de especies\nsp_dat$min_prof &lt;- sapply(sp_dat$spp, function(x){\n  \n  # leer los datos para una especie\n  X &lt;- datos_camaras[datos_camaras$Species == x, ]\n  \n  #  calcular el minimo de la profundidad\n  min_prf &lt;- min(X$Depth, na.rm = TRUE)\n  \n  return(min_prf)\n})\n\n# ciclar sobre los nombres de especies\nsp_dat$max_prof &lt;- sapply(sp_dat$spp, function(x){\n  \n  # leer los datos para una especie\n  X &lt;- datos_camaras[datos_camaras$Species == x, ]\n  \n  # calcular el maximo de profundidad\n  max_prf &lt;- max(X$Depth, na.rm = TRUE)\n  \n  return(max_prf)\n})\n\n\n\nCalcule el rango de profundidad (i.e. la diferencia entre el mínimo y el máximo de la profundidad) para cada especie y añádalo como una columna al cuadro de datos creado en el ejercicio 5. Las primeras 3 filas del cuadro de datos deben verse así:\n\n\n\n\n\n\n\n\nspp\nn_obs\nmin_prof\nmax_prof\nrango_prof\n\n\n\n\nxanthopterus\nxanthopterus\n145\n6.4\n31.6\n25.2\n\n\nlaticlavius\nlaticlavius\n25\n9.6\n31.6\n22.0\n\n\npolylepis\npolylepis\n26\n9.6\n30.0\n20.4\n\n\n\n\n\n\nRespuesta:\n\n\nCódigo\n# calcular el maximo menos el minimo de profundidad\nsp_dat$rango_prof &lt;- sp_dat$max_prof - sp_dat$min_prof\n\n\n\nIncluya el cuadro de datos generado en los ejercicios 5 a 7 como una tabla en su reporte usando la función DT del paquete datatable.\n\nRespuesta:\n\n\nCódigo\nlibrary(DT)\ndatatable(sp_dat)\n\n\n\n\n\n\n\nPublique el reporte en Rpubs y añada el enlace en el reporte (use un enlace en el texto)."
  },
  {
    "objectID": "respuestas_tarea5.html#información-de-la-sesión",
    "href": "respuestas_tarea5.html#información-de-la-sesión",
    "title": "Solución a la tarea 5",
    "section": "Información de la sesión",
    "text": "Información de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] DT_0.33\n\nloaded via a namespace (and not attached):\n [1] digest_0.6.37     R6_2.5.1          fastmap_1.2.0     xfun_0.47        \n [5] magrittr_2.0.3    cachem_1.1.0      knitr_1.48        htmltools_0.5.8.1\n [9] rmarkdown_2.28    lifecycle_1.0.4   cli_3.6.3         sass_0.4.9       \n[13] jquerylib_0.1.4   compiler_4.4.1    rstudioapi_0.16.0 tools_4.4.1      \n[17] bslib_0.8.0       evaluate_0.24.0   yaml_2.3.10       rlang_1.1.4      \n[21] jsonlite_1.8.8    htmlwidgets_1.6.4 crosstalk_1.2.1"
  },
  {
    "objectID": "tarea4.html#información-de-la-sesión",
    "href": "tarea4.html#información-de-la-sesión",
    "title": "Tarea 4",
    "section": "Información de la sesión",
    "text": "Información de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] DT_0.33             knitr_1.48          xaringanExtra_0.8.0\n[4] leaflet_2.2.2      \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.37     R6_2.5.1          fastmap_1.2.0     xfun_0.47        \n [5] fontawesome_0.5.2 magrittr_2.0.3    cachem_1.1.0      htmltools_0.5.8.1\n [9] rmarkdown_2.28    lifecycle_1.0.4   cli_3.6.3         sass_0.4.9       \n[13] jquerylib_0.1.4   compiler_4.4.1    rstudioapi_0.16.0 tools_4.4.1      \n[17] bslib_0.8.0       evaluate_0.24.0   yaml_2.3.10       formatR_1.14     \n[21] rlang_1.1.4       jsonlite_1.8.8    htmlwidgets_1.6.4 uuid_1.2-1       \n[25] crosstalk_1.2.1"
  },
  {
    "objectID": "estadistica_tradicional_regresion.html",
    "href": "estadistica_tradicional_regresion.html",
    "title": "Modelos estádisticos tradicionales como regresiones",
    "section": "",
    "text": "Entender los abordajes estadísticos tradicionales como regresiones\nAquí veremos las pruebas estadísticas más comunes y mostraremos cómo pueden representarse en el formato de regresión lineal. Esta sección se basa en este artículo. Consúltelo para obtener una descripción más detallada de las alternativas no paramétricas."
  },
  {
    "objectID": "estadistica_tradicional_regresion.html#prueba-de-wilcoxon-para-dos-promedios",
    "href": "estadistica_tradicional_regresion.html#prueba-de-wilcoxon-para-dos-promedios",
    "title": "Modelos estádisticos tradicionales como regresiones",
    "section": "6.1 Prueba de Wilcoxon para dos promedios",
    "text": "6.1 Prueba de Wilcoxon para dos promedios\nTambién conocida como prueba de Mann-Whitney, es la alternativa no paramétrica a la prueba t de dos promedios:\n\n\nCódigo\n# set seed\nset.seed(123)\n\n# number of observations\nn &lt;- 50\ny &lt;- rnorm(n = n, mean = 0.2, sd = 1)\n\n# create data frame\ny_data &lt;- data.frame(y)\n\n\ny\n\n\n [1] -0.3604756 -0.0301775  1.7587083  0.2705084  0.3292877  1.9150650\n [7]  0.6609162 -1.0650612 -0.4868529 -0.2456620  1.4240818  0.5598138\n[13]  0.6007715  0.3106827 -0.3558411  1.9869131  0.6978505 -1.7666172\n[19]  0.9013559 -0.2727914 -0.8678237 -0.0179749 -0.8260044 -0.5288912\n[25] -0.4250393 -1.4866933  1.0377870  0.3533731 -0.9381369  1.4538149\n[31]  0.6264642 -0.0950715  1.0951257  1.0781335  1.0215811  0.8886403\n[37]  0.7539177  0.1380883 -0.1059627 -0.1804710 -0.4947070 -0.0079173\n[43] -1.0653964  2.3689560  1.4079620 -0.9231086 -0.2028848 -0.2666554\n[49]  0.9799651  0.1166309\n\n\nCódigo\n# Wilcoxon / Mann-Whitney U\nwilcx_mod &lt;- wilcox.test(y_data$y)\n\nwilcx_mod\n\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  y_data$y\nV = 797, p-value = 0.12\nalternative hypothesis: true location is not equal to 0\n\n\nCódigo\nsigned_rank &lt;- function(x) sign(x) * rank(abs(x))\n\n# As linear model with our dummy-coded group_y2:\nwicx_lm_mod &lt;- lm(signed_rank(y) ~ 1, data = y_data) # compare to\n\nsummary(wicx_lm_mod)\n\n\n\nCall:\nlm(formula = signed_rank(y) ~ 1, data = y_data)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-53.38 -24.13   0.12  25.37  43.62 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)     6.38       4.09    1.56     0.12\n\nResidual standard error: 28.9 on 49 degrees of freedom\n\n\n\n\n\n\n\n\nmodel\np.value\n\n\n\n\n1 mean wilcoxon\n0.12482\n\n\nwilcoxon_lm\n0.12480"
  },
  {
    "objectID": "reportes_dinamicos.html",
    "href": "reportes_dinamicos.html",
    "title": "Reportes dinámicos",
    "section": "",
    "text": "Familiarizarse con el formato para reportes dinámicos Rmarkdown/quarto\nSer capaz de documentar el manejo y análisis de datos en R usando Rmarkdown/quarto\nPaquetes a utilizar en este manual:\nCódigo\n# cargar paquetes\n\nsketchy::load_packages(\n    c(\n      \"leaflet\",\n      \"remotes\",\n      \"hadley/emo\",\n      \"maRce10/sketchy\",\n      \"knitr\",\n      \"rmarkdown\",\n      \"rmdformats\",\n      \"revealjs\",\n      \"rticles\",\n      \"tufte\"\n    )\n)"
  },
  {
    "objectID": "reportes_dinamicos.html#ventajas-de-los-reportes-dinámicos-con-rmarkdownquarto",
    "href": "reportes_dinamicos.html#ventajas-de-los-reportes-dinámicos-con-rmarkdownquarto",
    "title": "Reportes dinámicos",
    "section": "1.1 Ventajas de los reportes dinámicos con Rmarkdown/quarto:",
    "text": "1.1 Ventajas de los reportes dinámicos con Rmarkdown/quarto:\n\nEl código R se puede incrustar en el informe, por lo que no es necesario mantener el informe y el código de R por separado\nIncluir el código R directamente en un informe proporciona una estructura intuitiva para reproducir los análisis\nEl texto del informe está escrito como texto normal, por lo que no se requieren conocimientos de programación (i.e. R o HTML) para comprenderlos\nEl resultado es un archivo HTML que incluye imágenes, bloques de código con los comandos de R, los resultados de estos códigos y texto. No se necesitan archivos adicionales, todo está incorporado en el archivo HTML.\nLos informes son fáciles de compartir por correo o publicarlos en línea\nEstos informes facilitan la colaboración y mejoran la reproducibilidad (entender los análisis es mucho mas fácil cuando hay texto explicativo, código de R, los resultados del código y los gráficos en un mismo archivo)\nSe actualizan fácilmente para incluir nuevos análisis y/o integrar nuevos datos"
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-1",
    "href": "reportes_dinamicos.html#ejercicio-1",
    "title": "Reportes dinámicos",
    "section": "2.1 Ejercicio 1",
    "text": "2.1 Ejercicio 1\nCree un nuevo archivo R Markdown o quarto, escriba algunas líneas de texto y haga clic en “Knit” para ver cómo se verá su reporte."
  },
  {
    "objectID": "reportes_dinamicos.html#crear-encabezados-de-varios-tamaños",
    "href": "reportes_dinamicos.html#crear-encabezados-de-varios-tamaños",
    "title": "Reportes dinámicos",
    "section": "3.1 Crear encabezados de varios tamaños",
    "text": "3.1 Crear encabezados de varios tamaños\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:"
  },
  {
    "objectID": "reportes_dinamicos.html#encabezado-2",
    "href": "reportes_dinamicos.html#encabezado-2",
    "title": "Reportes dinámicos",
    "section": "4.1 Encabezado 2",
    "text": "4.1 Encabezado 2\n\n4.1.1 Encabezado 3"
  },
  {
    "objectID": "reportes_dinamicos.html#opciones-del-texto",
    "href": "reportes_dinamicos.html#opciones-del-texto",
    "title": "Reportes dinámicos",
    "section": "4.2 Opciones del texto",
    "text": "4.2 Opciones del texto\n \nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\nHacer texto en negrita, itálico, tachado, o superíndice"
  },
  {
    "objectID": "reportes_dinamicos.html#añadir-una-imagen",
    "href": "reportes_dinamicos.html#añadir-una-imagen",
    "title": "Reportes dinámicos",
    "section": "4.3 Añadir una imagen",
    "text": "4.3 Añadir una imagen\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\n\n\n\n\n\n\n\n\n\nTambién podemos añadir una imagen con la función include_graphics() del paquete knitr.\nCódigo:\n\n\nCódigo\ninclude_graphics(\"./images/rmarkdown_icon.png\")\n\n\nResultado:\n\n\n\n\n\n\n\n\n\nNote que esta opción nos permite hacer uso de los argumentos del bloque de código dedicados a la graficación, y po r tanto es una opción mas flexible."
  },
  {
    "objectID": "reportes_dinamicos.html#crear-enlaces-hyperlinks",
    "href": "reportes_dinamicos.html#crear-enlaces-hyperlinks",
    "title": "Reportes dinámicos",
    "section": "4.4 Crear enlaces (‘hyperlinks’)",
    "text": "4.4 Crear enlaces (‘hyperlinks’)\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\nCrear un enlace a figshare"
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-2",
    "href": "reportes_dinamicos.html#ejercicio-2",
    "title": "Reportes dinámicos",
    "section": "4.5 Ejercicio 2",
    "text": "4.5 Ejercicio 2\n2.1 Cree unos encabezados y sub-encabezados en su documento Rmarkdown\n2.2 Añada texto con algunas palabras en negrita y en italica\n2.3 Incruste una imagen de su organismo favorito (o un gif)\n2.4 Añada un enlace URL"
  },
  {
    "objectID": "reportes_dinamicos.html#incrustar-código",
    "href": "reportes_dinamicos.html#incrustar-código",
    "title": "Reportes dinámicos",
    "section": "4.6 Incrustar código",
    "text": "4.6 Incrustar código\nPara incrustar el código de R, tenemos que definir un área donde se encuentra el código. Esta ‘área’ se conoce como un bloque de código (o ‘chunk’) y se define mediante:\n\n\n\n\n\n\n\n\n\n \nObserve que el recuadro de R está en gris, mientras que el resto está en fondo blanco. Todo lo que se incluye en el segmento se evalúa y muestra de acuerdo con las especificaciones, aunque estas se pueden modificar.\n \nPodemos, por ejemplo, agregar una nueva columna al conjunto de datos de ejemplo de iris:\n\n\n\n\n\n\n\n\n\nResultado:\n\n\nCódigo\ndata(iris)\n\niris$random.var &lt;- rnorm(n = nrow(iris))\n\nhead(iris)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\nrandom.var\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n-1.09520\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n-0.06402\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n0.95252\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n-0.40435\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n1.53508\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n-0.57944\n\n\n\n\n\n\n \nCuando se procesa su documento, el segmento de código se muestra en un cuadro gris y los resultados de ese código se muestran en un cuadro blanco. ¿Qué pasa si solo desea que se muestre la salida de su código? ¿O que su código se muestre pero no se ejecute realmente? Hay argumentos que puede agregar a cada uno de sus bloques para especificar estas y otras opciones:"
  },
  {
    "objectID": "reportes_dinamicos.html#ocultar-código",
    "href": "reportes_dinamicos.html#ocultar-código",
    "title": "Reportes dinámicos",
    "section": "4.7 Ocultar código",
    "text": "4.7 Ocultar código\nAñadir el argumento echo=FALSE\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\nrandom.var\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n0.45822\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n0.88974\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n-1.54111\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n-0.83230\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n0.10588\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n-0.83604\n\n\n\n\n\n\n \nPuede ver que el código está oculto pero se muestran los resultados.\nEsta guía sobre las opciones de los bloques de código puede ser muy útil:\n\n\n\n\n\n\n\n\n\n \nEn este enlace se detallan todos los argumentos disponibles para personalizar los bloques de código."
  },
  {
    "objectID": "reportes_dinamicos.html#incrustar-gráficos",
    "href": "reportes_dinamicos.html#incrustar-gráficos",
    "title": "Reportes dinámicos",
    "section": "4.8 Incrustar gráficos",
    "text": "4.8 Incrustar gráficos\nLos gráficos se pueden incrustar en documentos Rmarkdown simplemente usando funciones de graficación como lo haría en un script de R normal.\n\n4.8.0.1 Código:\n\n\n\n\n\n\n\n\n\n \n\n\n4.8.0.2 Resultado:"
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-3",
    "href": "reportes_dinamicos.html#ejercicio-3",
    "title": "Reportes dinámicos",
    "section": "4.9 Ejercicio 3",
    "text": "4.9 Ejercicio 3\n3.1 Utilice los argumentos eval, collapse con diferentes valores (TRUE o FALSE) en un segmento donde corre head(iris). ¿Cómo afectan el resultado?\n3.2 Haga lo mismo con los argumentos out.width, fig.width,dpi y fig.height en un segmento que cree un gráfico. ¿Cómo afecta esta vez?"
  },
  {
    "objectID": "reportes_dinamicos.html#incrustar-código-de-r-en-el-texto",
    "href": "reportes_dinamicos.html#incrustar-código-de-r-en-el-texto",
    "title": "Reportes dinámicos",
    "section": "4.10 Incrustar código de R en el texto",
    "text": "4.10 Incrustar código de R en el texto\nEs posible que haya notado a lo largo de este tutorial que tengo pequeños fragmentos de texto que parecen “bloques de código”. Esto se conoce como incrustación de código en texto.\nEsto se puede hacer de dos maneras:\n\n4.10.0.1 1.Dar un texto con la apariencia de un segmento de código:\n\n\n\n4.10.0.2 Código:\n\n\n\n\n\n\n\n\n\n \n\n\n4.10.0.3 Resultado:\nEl promedio del largo del sépalo es mean(iris$Sepal.Length)\n \n\n\n4.10.0.4 2. Evaluar el código en el texto\n\n\n4.10.0.5 Código:\n\n\n\n\n\n\n\n\n\n\n\n4.10.0.6 Resultado:\nEl promedio del largo de sépalo para setosa es 5.006."
  },
  {
    "objectID": "reportes_dinamicos.html#metadatos-yaml",
    "href": "reportes_dinamicos.html#metadatos-yaml",
    "title": "Reportes dinámicos",
    "section": "5.1 Metadatos (YAML)",
    "text": "5.1 Metadatos (YAML)\nHay tres componentes básicos de un documento de R Markdown: los metadatos, el texto y el código. Los metadatos se escriben entre el par de tres guiones (“- - -”) generalmente al inicio del documento. La sintaxis de los metadatos es YAML (YAML Ain’t Markup Language), por lo que a veces también se denomina metadatos YAML. La sangría es importante en YAML, así que debe añadirla a los subcampos (con respecto a un campo superior).\nEste encabezado muestra las opciones mas comúnmente usadas en los metadatos YAML:\n\n\nCódigo\n---\ntitle: \"Un titulo descriptivo y sin faltas ortograficas\"\nauthor: \"Marcelo Araya\"\ndate: \"`r Sys.Date()`\"\noutput: # Varios outputs mostrados solo para el ejemplo\n  html_document:\n    fig_caption: yes\n    number_sections: yes\n    toc: yes\n    toc_float: yes\n    df_print: paged\n---\n\n\nEn este enlace se explican en detalle las opciones disponibles en el encabezado YAML de archivos Rmarkdown."
  },
  {
    "objectID": "reportes_dinamicos.html#emojis",
    "href": "reportes_dinamicos.html#emojis",
    "title": "Reportes dinámicos",
    "section": "5.2 Emojis",
    "text": "5.2 Emojis\nEl paquete emo permite añadir emojis al evaluar un código:\n\nCódigo\nemo::ji(\"costa_rica\")\n\n🇨🇷\nTambien se puede incrustar en el texto 🇨🇷, como lo vimos mas arriba ⬆️ (ji(\"up_arrow\"))"
  },
  {
    "objectID": "reportes_dinamicos.html#cuadros-con-knitrkable",
    "href": "reportes_dinamicos.html#cuadros-con-knitrkable",
    "title": "Reportes dinámicos",
    "section": "5.3 Cuadros con knitr::kable",
    "text": "5.3 Cuadros con knitr::kable\nEl paquete knitr también provee una función para mostrar datos tabulares de forma ordenada y ‘limpia’ en los reportes dínamicos:\n\n\nCódigo\nknitr::kable(iris[1:10, ])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\nrandom.var\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n0.45822\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n0.88974\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n-1.54111\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n-0.83230\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n0.10588\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n-0.83604\n\n\n4.6\n3.4\n1.4\n0.3\nsetosa\n0.16728\n\n\n5.0\n3.4\n1.5\n0.2\nsetosa\n-0.22475\n\n\n4.4\n2.9\n1.4\n0.2\nsetosa\n1.49379\n\n\n4.9\n3.1\n1.5\n0.1\nsetosa\n-0.79710\n\n\n\n\n\n\n \nEl paquete kableExtra complementa esta función con muchas herramientas para personalizar el formato de las tablas en reportes dinámicos en R."
  },
  {
    "objectID": "reportes_dinamicos.html#opciones-adicionales-en-knitr",
    "href": "reportes_dinamicos.html#opciones-adicionales-en-knitr",
    "title": "Reportes dinámicos",
    "section": "5.4 Opciones adicionales en knitr",
    "text": "5.4 Opciones adicionales en knitr\nEl argumento opts_knit de knitr permite definir opciones globales (aplicables a todos los bloques a menos que se re-definan):\n\n\nCódigo\nopts_chunk$set(root.dir = \"..\", eval = TRUE, echo = FALSE)"
  },
  {
    "objectID": "reportes_dinamicos.html#presentaciones-y-otros-opciones-de-formato",
    "href": "reportes_dinamicos.html#presentaciones-y-otros-opciones-de-formato",
    "title": "Reportes dinámicos",
    "section": "5.5 Presentaciones y otros opciones de formato",
    "text": "5.5 Presentaciones y otros opciones de formato\nNote en la ventana de creación de un nuevo documento Rmarkdown las opciones adicionales de formato:\n\n\n\n\n\n\n\n\n\n \nLos reportes dinámicos se pueden generar en otros formatos incluyendo presentaciones, pdf y documentos de word."
  },
  {
    "objectID": "reportes_dinamicos.html#plantillas-de-rmarkdown",
    "href": "reportes_dinamicos.html#plantillas-de-rmarkdown",
    "title": "Reportes dinámicos",
    "section": "5.6 Plantillas de Rmarkdown",
    "text": "5.6 Plantillas de Rmarkdown\nEl paquete Rmarkdown puede generar resultados en HTML, PDF, MS Word, viñetas de paquetes de R, presentaciones Beamer y HTML5. Los formatos adicionales (o ‘variantes’ de estos formatos) están disponibles en otros paquetes de R. Algunos de esos paquetes son:\n\nrmdformats\nreveljs\nartículos\ntufte\n\nUna vez estos paquetes han sido instalados, los nuevos formatos estarán disponibles a través del nuevo cuadro de diálogo Rmarkdown:"
  },
  {
    "objectID": "reportes_dinamicos.html#html-widgets",
    "href": "reportes_dinamicos.html#html-widgets",
    "title": "Reportes dinámicos",
    "section": "6.1 HTML widgets",
    "text": "6.1 HTML widgets\nLos HTML Widgets se implementan con el paquete R htmlwidgets, que conecta herramientas de JavaScript que crean aplicaciones interactivas, como gráficos y tablas Se han desarrollado varios paquetes que emplean HTML widgets como dygraphs, DT y leaflet. En este sitio (https://www.htmlwidgets.org) se muestran una variedad de widgets disponibles así como instrucciones de como desarrollarlos.\nEl siguiente código utiliza el paquete leaflet para generar un mapa interactivo:\n\nCódigo\nsketchy::load_packages(\"leaflet\")\n\nll_map &lt;- leaflet()\n\nll_map &lt;- addTiles(map = ll_map)\n\nll_map &lt;-\n  setView(\n    map = ll_map,\n    lat = 5.527448,\n    lng = -87.057245,\n    zoom = 13\n  )\n\naddPopups(\n  map = ll_map,\n  lat = 5.527448,\n  lng = -87.057245,\n  popup = 'Isla del Coco'\n)"
  },
  {
    "objectID": "reportes_dinamicos.html#aplicaciones-shiny",
    "href": "reportes_dinamicos.html#aplicaciones-shiny",
    "title": "Reportes dinámicos",
    "section": "6.2 Aplicaciones shiny",
    "text": "6.2 Aplicaciones shiny\nEl paquete shiny crea aplicaciones web interactivas en R. Para llamar al código shiny desde un documento R Markdown, agregue ‘runtime’: shiny a los metadatos YAML, como en este ejemplo:\n\n\nCódigo\n---\ntitle: \"Documento Shiny\"\noutput: html_document\nruntime: shiny\n---\n\n\n \nEl siguiente código crea una aplicación shiny dentro del documento Rmarkdown:\n\n\nCódigo\nsketchy::load_packages(\"shiny\")\n\nui &lt;- fluidPage(\n  \n  titlePanel(\"Ejemplo\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"bins\",\n                  label = \"Numero de barras:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n      \n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n \n  output$distPlot &lt;- renderPlot({\n    \n    x    &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    \n    hist(x, breaks = bins, col = \"#3E4A89FF\", border = \"white\",\n         xlab = \"Tiempo de espera para la siguiente erupcion\",\n         main = \"Histograma del tiempo de espera\")\n  })\n}\n\n# Crear Shiny app\nshinyApp(ui = ui, server = server)\n\n\n \nNote que esta aplicación no funciona en documentos estáticos de Rmarkdown. En el sitio https://shiny.rstudio.com/gallery pueden encontrar muchos ejemplos de aplicaciones shiny. Estas aplicaciones son complejas de incluir en archivos auto-contenidos y por ello no son tan amigables para reportes dinámicos como los que podemos generar con R markdown."
  },
  {
    "objectID": "reportes_dinamicos.html#proyectos-de-rstudio",
    "href": "reportes_dinamicos.html#proyectos-de-rstudio",
    "title": "Reportes dinámicos",
    "section": "8.1 Proyectos de Rstudio",
    "text": "8.1 Proyectos de Rstudio\nLos proyectos de Rstudio crean carpetas donde se guardan los archivos relacionados a un análisis específico (código y datos) y hacen de esta carpeta el directorio de trabajo por defecto cuando se abre el proyecto. Se pueden crear de esta forma:\n\n\n\n\n\n\n\n\n\nLuego aparecera una seria de ventanas donde pueden escoger que tipo de proyecto y el nombre de este:"
  },
  {
    "objectID": "reportes_dinamicos.html#compendios-de-investigación",
    "href": "reportes_dinamicos.html#compendios-de-investigación",
    "title": "Reportes dinámicos",
    "section": "8.2 Compendios de investigación",
    "text": "8.2 Compendios de investigación\nLos compendios de investigación son estructuras de carpetas pre-definidas que permiten seguir un orden lógico e intuitivo para organizar los archivos usados y generados en un análisis de datos de un proyecto de investigación. El paquete sketchy genera estos compendios, permitiendo al usuario seleccionar entre una gama de compendios comunes en la comunidad científica. Este ejemplo crea el compendio básico (uno de los 14 que vienen con el paquete):\n\n\nCódigo\npath &lt;- tempdir()\n\nmake_compendium(\n  name = \"proyecto_x\",\n  path = path,\n  format = \"basic\",\n  Rproj = TRUE\n)\n\n\nCreating directories ...\nproyecto_x\n│   \n├── data/  \n│   ├── processed/  # modified/rearranged data\n│   └── raw/  # original data\n├── manuscript/  # manuscript/poster figures\n├── output/  # all non-data products of data analysis\n└── scripts/  # code\nDone.\n\n\nEl paquete crea archivos Rmarkdown con plantillas para el análisis de datos (carpeta “scripts”) y escritura de manuscritos (carpeta “manuscript”). Corra path en la consola de R para ver la dirección de la carpeta donde se creo el compendio."
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-4",
    "href": "reportes_dinamicos.html#ejercicio-4",
    "title": "Reportes dinámicos",
    "section": "8.3 Ejercicio 4",
    "text": "8.3 Ejercicio 4\n\nCree un reporte dinámico que incluya un mapa dinámico de Costa Rica usando el paquete leaflet\nReproduzca alguno de los ejemplos disponibles en el sitio del paquete dygraphs (https://rstudio.github.io/dygraphs/) e incrústelo en su reporte dinámico\nInstale el paquete kableExtra y incruste en su reporte el códifo de ejemplo en la documentación de la función kable_styling() de ese paquete\nCree una presentación Rmarkdown utilizando la opción “Presentation” en la ventana de creación\nGenere un reporte dinámico en formato PDF\nCree un proyecto de Rstudio para organizar los contenidos del curso\nCree un compendio de investigación con sketchy"
  },
  {
    "objectID": "reportes_dinamicos.html#referencias",
    "href": "reportes_dinamicos.html#referencias",
    "title": "Reportes dinámicos",
    "section": "8.4 Referencias",
    "text": "8.4 Referencias\n\nR Markdown: The Definitive Guide\nRmarkdown custom format\nRmarkdown website\nJacolien van Rij: Rmarkdown variants\nDanielle Quinn: R Lessons\nVaidyanathan, Ramnath, Yihui Xie, JJ Allaire, Joe Cheng, and Kenton Russell. 2019. Htmlwidgets: HTML Widgets for R. https://github.com/ramnathv/htmlwidgets.\n\n\n\nInformación de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] tufte_0.13       rticles_0.27     revealjs_0.9     rmdformats_1.0.4\n [5] rmarkdown_2.28   knitr_1.48       sketchy_1.0.3    emo_0.0.0.9000  \n [9] remotes_2.5.0    leaflet_2.2.2   \n\nloaded via a namespace (and not attached):\n [1] jsonlite_1.8.8      compiler_4.4.1      crayon_1.5.3       \n [4] stringr_1.5.1       assertthat_0.2.1    jquerylib_0.1.4    \n [7] yaml_2.3.10         fastmap_1.2.0       R6_2.5.1           \n[10] generics_0.1.3      htmlwidgets_1.6.4   bookdown_0.40      \n[13] lubridate_1.9.3     xaringanExtra_0.8.0 rlang_1.1.4        \n[16] stringi_1.8.4       xfun_0.47           timechange_0.3.0   \n[19] cli_3.6.3           magrittr_2.0.3      crosstalk_1.2.1    \n[22] digest_0.6.37       rstudioapi_0.16.0   packrat_0.9.2      \n[25] lifecycle_1.0.4     vctrs_0.6.5         evaluate_0.24.0    \n[28] glue_1.7.0          purrr_1.0.2         tools_4.4.1        \n[31] htmltools_0.5.8.1"
  },
  {
    "objectID": "tarea5.html",
    "href": "tarea5.html",
    "title": "Tarea 5",
    "section": "",
    "text": "Para esta tarea trabajaremos con los datos de camaras submarinas usados en clase. Estos datos muestran la salida de un programa de identificación automática de especies marinas en videos pasivos tomados en la columna de agua. Para cada video analizado el programa genera un archivo de texto (.TXT) con una fila para cada especie detectada mas una serie de metadatos asociados a la detección. Los datos se ven así:\nPrimero debemos preparar los archivos de ejemplo:\nCódigo\n# definir directorio a donde guardar los archivos\ndirectorio &lt;- \"DIRECCION_DONDE_GUARDAR_LOS ARCHIVOS_DE_EJEMPLO\"\n\n# guardar archivos\ndownload.file(\n  url = paste0(\n    \"https://github.com/maRce10/ucr_r_avanzado/\",\n    \"raw/master/additional_files/datos_camara_submarina.zip\"\n  ),\n  destfile = file.path(directorio, \"datos_camara_submarina.zip\")\n)\n\n# extraerlos del zip\nunzip(\n  zipfile = file.path(directorio, \"datos_camara_submarina.zip\"),\n  exdir = directorio\n)\n\n# hacer vector con nombre y direccion de archivos\narchivos_txt &lt;-\n  list.files(\n    path = directorio,\n    full.names = TRUE,\n    pattern = \"TXT$\"\n  )\nTambién pueden bajar el archivo directamente de este enlance. Recuerde extraer los archivos y hacer el vector con los nombres de los archivos (correr líneas de la 9 a la 13).\nSi todo salió bien el vector “archivos_txt” debería tener 19 elementos:\nCódigo\nlength(archivos_txt)\n\n\n[1] 19"
  },
  {
    "objectID": "tarea5.html#información-de-la-sesión",
    "href": "tarea5.html#información-de-la-sesión",
    "title": "Tarea 5",
    "section": "Información de la sesión",
    "text": "Información de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] knitr_1.48\n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.4.1    fastmap_1.2.0     cli_3.6.3        \n [5] tools_4.4.1       htmltools_0.5.8.1 rstudioapi_0.16.0 yaml_2.3.10      \n [9] rmarkdown_2.28    jsonlite_1.8.8    xfun_0.47         digest_0.6.37    \n[13] rlang_1.1.4       evaluate_0.24.0"
  },
  {
    "objectID": "modelos_de_regresion.html",
    "href": "modelos_de_regresion.html",
    "title": "Modelos de regresión",
    "section": "",
    "text": "Paquetes a utilizar en este manual:\nCódigo\n# instalar/cargar paquetes\n\nsketchy::load_packages(\n  c(\"ggplot2\", \n    \"viridis\", \n    \"lmerTest\", \n    \"sjPlot\")\n  )"
  },
  {
    "objectID": "modelos_de_regresion.html#modelo-solo-con-intercepto",
    "href": "modelos_de_regresion.html#modelo-solo-con-intercepto",
    "title": "Modelos de regresión",
    "section": "1.1 Modelo solo con intercepto",
    "text": "1.1 Modelo solo con intercepto\nPrimero vamos a crear una variable numérica de respuesta:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\n\n#  variables aleatorias\ny &lt;- rnorm(n = n, mean = 0, sd = 1)\n\n# put it in a data frame\ny_data &lt;- data.frame(y)\n\n\n \nEsta única variable puede introducirse en un modelo de regresión sólo con intercepto. Para ello, debemos suministrar la fórmula del modelo y los datos a lm():\n\n\nCódigo\n# run model\ny_mod &lt;- lm(formula = y ~ 1, data = y_data)\n\n\n \nLo que equivale a:\n\n\\(\\hat{Y} \\sim \\beta_{o}\\)\n\n \nPodemos obtener el resumen por defecto de los resultados del modelo ejecutando summary() en el objeto de salida ‘y_mod’:\n\n\nCódigo\nsummary(y_mod)\n\n\n\nCall:\nlm(formula = y ~ 1, data = y_data)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.001 -0.594 -0.107  0.664  2.135 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   0.0344     0.1309    0.26     0.79\n\nResidual standard error: 0.926 on 49 degrees of freedom\n\n\n \nPuede ser bastante informativo graficar los tamaños de efecto (aunque en este caso sólo tenemos uno):\n\n\nCódigo\nci_df &lt;- data.frame(param = names(y_mod$coefficients), \n                    est = y_mod$coefficients, confint(y_mod))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nPara evaluar la importancia de la asociación nos centramos en la tabla de coeficientes:\n\n\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept) 0.034404    0.13094 0.26275  0.79385\n\n\n\nEn este ejemplo no hay predictores en el modelo, por lo que sólo tenemos una estimación para el intercepto (\\(\\beta_0\\))\nEl modelo nos dice que el intercepto se estima en 0.0344 y que este valor no es significativamente diferente de 0 (valor p = 0.79385)\nEn este caso el intercepto es simplemente la media de la variable de respuesta\n\n\n\nCódigo\nmean(y_data$y)\n\n\n[1] 0.034404\n\n\n \n\nRara vez tenemos predicciones sobre el intercepto, por lo que tendemos a ignorar esta estimación.\n\n\n \n\n\nCaso de estudio\n\n \n\nRuhs, E. C., Martin, L. B., & Downs, C. J. (2020). The impacts of body mass on immune cell concentrations in birds. Proceedings of the Royal Society B, 287(1934), 20200655.\n\n“Encontramos que un modelo sólo con intercepto (intercept-only model) explicaba mejor las concentraciones de linfocitos y eosinófilos en las aves, indicando que las concentraciones de estos tipos de células eran independientes de la masa corporal.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 3\n \n\nCambie el argumento ‘mean’ en la llamada de la función “rnorm()` en la simulación para el modelo de solo intercepto un valor distinto de 0 y observe cómo cambian los valores en la tabla de coeficientes\nCambia el argumento sd en la llamada a la función rnorm() por un valor más alto y observe cómo cambian los valores en la tabla de coeficientes"
  },
  {
    "objectID": "modelos_de_regresion.html#añadir-un-predictor-no-asociado",
    "href": "modelos_de_regresion.html#añadir-un-predictor-no-asociado",
    "title": "Modelos de regresión",
    "section": "1.2 Añadir un predictor no asociado",
    "text": "1.2 Añadir un predictor no asociado\nPodemos crear 2 variables numéricas no relacionadas así:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\n\n#  variables aleatorias\ny &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\n\n# crear data frame\nxy_datos &lt;- data.frame(x1, y)\n\n\n \nEstas dos variables pueden introducirse en un modelo de regresión para evaluar la asociación entre ellas:\n\n\nCódigo\n# construir model\nxy_mod &lt;- lm(formula = y ~ x1, data = xy_datos)\n\n# graficar\nggplot(xy_datos, aes(x = x1, y = y)) + \n  geom_smooth(method = \"lm\", se = FALSE) + \n  geom_point() # graficar points\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nQue es equivalente a esto:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1}\\)\n\n \nImprimamos el resumen de este modelo:\n\n\nCódigo\nsummary(xy_mod)\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.004 -0.624 -0.123  0.687  2.106 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   0.0398     0.1340    0.30     0.77\nx1           -0.0367     0.1475   -0.25     0.80\n\nResidual standard error: 0.935 on 48 degrees of freedom\nMultiple R-squared:  0.00129,   Adjusted R-squared:  -0.0195 \nF-statistic: 0.0618 on 1 and 48 DF,  p-value: 0.805\n\n\n \n… y graficar los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod$coefficients), \n                    est = xy_mod$coefficients, confint(xy_mod))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \nDeberíamos “diagnosticar” la idoneidad del modelo inspeccionando más de cerca la distribución de los residuos. La función plot_model() del paquete sjPlot hace un buen trabajo para crear gráficos de diagnóstico para modelos lineales:\n\n\nCódigo\nplot_model(xy_mod, type = \"diag\")\n\n\n[[1]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con coeficientes:\n\n\n             Estimate Std. Error  t value Pr(&gt;|t|)\n(Intercept)  0.039774    0.13396  0.29690  0.76782\nx1          -0.036679    0.14750 -0.24867  0.80467\n\n\n \n\nEn este ejemplo hemos añadido un predictor al modelo, por lo que hemos obtenido una estimado adicional (y una fila extra, ‘x1’)\nEl modelo nos dice que la estimación de ‘x1’ es -0.03668 y que no es significativamente diferente de 0 (p = 0.80467)"
  },
  {
    "objectID": "modelos_de_regresion.html#simular-un-predictor-asociado",
    "href": "modelos_de_regresion.html#simular-un-predictor-asociado",
    "title": "Modelos de regresión",
    "section": "1.3 Simular un predictor asociado",
    "text": "1.3 Simular un predictor asociado\nPodemos utilizar la fórmula del modelo lineal anterior para simular dos variables continuas asociadas así:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nerror &lt;- rnorm(n = n, sd = 3)\n\n# variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + b1 * x1 + error\n\n# crear data frame\nxy_datos2 &lt;- data.frame(x1, y)\n\n\n \nNote que también hemos añadido un término de error, por lo que la asociación no es perfecta. Vamos a correr el modelo y graficar la asociación entre las dos variables:\n\n\nCódigo\n# construir model\nxy_mod2 &lt;- lm(formula = y ~ x1, data = xy_datos2)\n\n# graficar\nggplot(xy_datos2, aes(x = x1, y = y)) + \n  geom_smooth(method = \"lm\", se = FALSE) +  \n  geom_point() # graficar points\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nLa fórmula es la misma que la del modelo anterior:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1}\\)\n\n \nEste es el resumen del modelo:\n\n\nCódigo\nsummary(xy_mod2)\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos2)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n -6.01  -1.87  -0.37   2.06   6.32 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -3.881      0.402   -9.66  7.9e-13 ***\nx1             2.890      0.442    6.53  3.9e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.8 on 48 degrees of freedom\nMultiple R-squared:  0.471, Adjusted R-squared:  0.459 \nF-statistic: 42.7 on 1 and 48 DF,  p-value: 3.85e-08\n\n\n \n.. el gráfico con los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod2$coefficients), \n                    est = xy_mod2$coefficients, confint(xy_mod2))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n… y los gráficos diagnósticos del modelo:\n\n\nCódigo\nplot_model(xy_mod2, type = \"diag\")\n\n\n[[1]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -3.8807    0.40188 -9.6562 7.8616e-13\nx1            2.8900    0.44249  6.5311 3.8537e-08\n\n\n\nEl modelo nos dice que \\(beta_1\\) (el tamaño de efecto de ‘x1’) es 2.88996 y que es significativamente diferente de 0 (p = 3.85365^{-8})\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) (the effect size of ‘x1’) was set to 3 and was estimated as 2.89 by the model\n\n\n\n\n\nCaso de estudio\n\n \n\nKeenan EL, Odom KJ, Araya-Salas M, Horton KG, Strimas-Mackey M, Meatte MA, Mann NI, Slater PJ, Price JJ, and Templeton CN. 2020. Breeding season length predicts duet coordination and consistency in Neotropical wrens (Troglodytidae). Proceeding of the Royal Society B. 20202482\n\n\n\n\n\n\n\n\n\n\n \n“… la coordinación y la consistencia de los duetos son mayores en las especies con temporadas de apareamiento especialmente largas.”\n\n\n\n\n\n\n\n\n\n \n\n\nEjercicio 4\n\nAumente el tamaño de la muestra (n) a 1000 o más\n¿Cómo cambiaron los estimados del tamaño de efecto (\\(\\beta\\))?\n¿Cómo cambió los intervalos de confianza del tamaño de efecto?\nAhora cambie n a 15 y compruebe de nuevo las estimaciones del modelo (esta vez compruebe también el valor p)"
  },
  {
    "objectID": "modelos_de_regresion.html#varios-predictores-regresión-múltiple",
    "href": "modelos_de_regresion.html#varios-predictores-regresión-múltiple",
    "title": "Modelos de regresión",
    "section": "1.4 Varios predictores: regresión múltiple",
    "text": "1.4 Varios predictores: regresión múltiple\nLa regresión lineal múltiple es una extensión del modelo de regresión lineal simple que puede tomar varios predictores:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1} + \\cdots + \\beta_{n} * x_{n}\\)\n\n \nLa fórmula parece compleja, pero sólo quiere decir que cualquier parámetro adicional tendrá su propia estimación (\\(\\beta\\)). La fórmula para una regresión lineal de dos predictores se ve así:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1} + \\beta_{2} * x_{2}\\)\n\n \n… y se puede simular así:\n\n\nCódigo\n# semila\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- -2\nerror &lt;- rnorm(n = n, mean = 0, sd = 3)\n\n# variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx2 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + b1 * x1 + b2 * x2 + error\n\n# crear un data frame\nxy_datos_multp &lt;- data.frame(x1, x2, y)\n\n# construir el modelo\nxy_mod_multp &lt;- lm(formula = y ~ x1 + x2, data = xy_datos_multp)\n\nsummary(xy_mod_multp)\n\n\n\nCall:\nlm(formula = y ~ x1 + x2, data = xy_datos_multp)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-5.986 -1.893 -0.363  2.002  6.413 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -3.865      0.417   -9.27  3.5e-12 ***\nx1             2.901      0.453    6.41  6.4e-08 ***\nx2            -1.932      0.414   -4.67  2.6e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.83 on 47 degrees of freedom\nMultiple R-squared:  0.612, Adjusted R-squared:  0.595 \nF-statistic:   37 on 2 and 47 DF,  p-value: 2.23e-10\n\n\n \n… graficar los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod_multp$coefficients), \n                    est = xy_mod_multp$coefficients, confint(xy_mod_multp))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n… y los gráficos diagnósticos:\n\n\nCódigo\nplot_model(xy_mod_multp, type = \"diag\")\n\n\n[[1]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nHay un punto importante que es necesario enfatizar aquí: la regresión múltiple estima el efecto de un predictor después de tener en cuenta el efecto de los demás predictores del modelo. En otras palabras, los nuevos predictores del modelo tratarán de explicar la variación de los datos que no fue explicada por los otros predictores. Así que el resultado de la regresión múltiple no es equivalente a los resultados de las regresiones lineales simples sobre los predictores por separado. Esto puede demostrarse fácilmente corriendo esas regresiones:\n\n\nCódigo\ncoef(xy_mod_multp)# Resumen del modelo de multiple \n\n\n(Intercept)          x1          x2 \n    -3.8652      2.9015     -1.9324 \n\n\nCódigo\n# Regresión simple de Y con A\nmod_x1 &lt;- lm(y ~ x1, data = xy_datos_multp)\ncoef(mod_x1)  # Resumen del modelo de regresión \n\n\n(Intercept)          x1 \n    -3.4228      3.2310 \n\n\nCódigo\n# Regresión simple de Y con A\nmod_x2 &lt;- lm(y ~ x2, data = xy_datos_multp)\ncoef(mod_x2)  # Resumen del modelo de regresión\n\n\n(Intercept)          x2 \n    -3.5456     -2.3468 \n\n\nComo vemos los tamaños de efecto para el mismo predictor difieren entre la regresión multiple y la simple. Esto se debe a que en la regresion multiple ajusta los predictores para que se comporten como si fueran ortogonales entre sí. Esto lo podemos simular sacando los residuos de cada predictor en una regresión contra todos los otros predictores en la regresión multiple. En nuestro caso es fácil ya que solo tenemos 2 predictores:\n\n\nCódigo\n# Regresión de x1 sobre x2 para obtener los residuos\nmod_resid_x1 &lt;- lm(x1 ~ x2, data = xy_datos_multp)\n\n# Obtener los residuos\nxy_datos_multp$residuos_x1 &lt;- resid(mod_resid_x1)  \n\n# Regresión de x2 sobre x1 para obtener los residuos\nmod_resid_x2 &lt;- lm(x2 ~ x1, data = xy_datos_multp)\n\n# Obtener los residuos \nxy_datos_multp$residuos_x2 &lt;- resid(mod_resid_x2)  \n\n\nAhora si corremos las regresiones simples con estos residuos, los tamaños de efecto coinciden con los obtenidos en la regresión multiple:\n\n\nCódigo\n# Regresión de Y sobre los residuos de A\nmod_resid_reg_x1 &lt;- lm(y ~ residuos_x1, data = xy_datos_multp)\n\n# Regresión de Y sobre los residuos de B\nmod_resid_reg_x2 &lt;- lm(y ~ residuos_x2, data = xy_datos_multp)\n\n# Resúmenes finales de los modelos para comparar\ncoef(xy_mod_multp)[-1]\n\n\n     x1      x2 \n 2.9015 -1.9324 \n\n\nCódigo\nc(coef(mod_resid_reg_x1)[-1], coef(mod_resid_reg_x2)[-1])\n\n\nresiduos_x1 residuos_x2 \n     2.9015     -1.9324 \n\n\nPor comodidad, hemos utilizado coef() para extraer sólo los estimado de la regresión, pero los valores son los mismos que obtenemos con summary(model).\nEste punto se demuestra además por el hecho de que, si uno de los predictores no tiene ninguna influencia en la respuesta, el efecto del predictor adicional convergerá a su efecto en una regresión lineal simple. Para simular este escenario, fijamos b2 en 0:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- 0\nerror &lt;- rnorm(n = n, mean = 0, sd = 1)\n\n#  variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx2 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + b1 * x1 + b2 * x2 + error\n\n# crear data frame\nxy_datos &lt;- data.frame(x1, x2, y)\n\n# construir modelos\nxy_mod &lt;- lm(formula = y ~ x1 + x2, data = xy_datos)\nx1y_mod &lt;- lm(formula = y ~ x1, data = xy_datos)\n\n# shortcut to coefficients\ncoef(xy_mod)\n\n\n(Intercept)          x1          x2 \n  -3.955064    2.967166    0.022549 \n\n\nCódigo\ncoef(x1y_mod)\n\n\n(Intercept)          x1 \n    -3.9602      2.9633 \n\n\nEl estimado de \\(\\beta_1\\) fue casi el mismo en la regresión múltiple (2.96717) y en la regresión de un solo predictor (2.96332)\n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -3.8652    0.41695 -9.2702 3.4856e-12\nx1            2.9015    0.45260  6.4108 6.4137e-08\nx2           -1.9324    0.41422 -4.6650 2.5851e-05\n\n\n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 2.9015 y que es significativamente diferente de 0 (p = 6.41368^{-8}). Este es el efecto de ‘x1’ sobre ‘y’ una vez removida la variación explicada por ‘x2’.\nTambién se encontró que el \\(\\beta_2\\) (el tamaño de efecto de ‘x2’) es -1.93235 y que también es significativamente diferente de 0 (p = 2.58513^{-5}). Este es el efecto de ‘x2’ sobre ‘y’ una vez removida la variación explicada por ‘x1’.\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se fijó en 3 y se estimó como 2.901.\n\\(\\beta_2\\) (el tamaño de efecto de ‘x2’) se fijó en 0 y se estimó como -1.932.\n\n\n\n \n\n\nCaso de estudio\n\n \n\nAraya-Salas M, P González-Gómez, K Wojczulanis-Jakubas, V López III & T Wright. 2018. Spatial memory is as important as weapon and body size for territorial ownership in a lekking hummingbird. Scientific Reports. 13, e0189969\n\n“La memoria espacial, el tamaño corporal y el largo de la punta del pico … predijeron positivamente la probabilidad de adquirir y defender un territorio.”\n\n\n\n\n\n\n\n\n\n \n\n\nEjercicio 5\n \nLa siguiente simulación genera un par de predictores continuos altamente colineales:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 30\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- -2\nerror &lt;- rnorm(n = n, mean = 0, sd = 1)\n\n#  variables aleatorias colineales\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx2 &lt;-  x1 + rnorm(n = n, mean = 0, sd = 0.2) # hacer x2 colineal con x1\ny &lt;- b0 + b1 * x1 + b2 * x2 + error\n\n# crear data frame\nxy_datos &lt;- data.frame(x1, x2, y)\n\ncor(x1, x2)\n\n\n[1] 0.97812\n\n\n\n\nCódigo\n# graficar\nggplot(data = xy_datos, aes(x = x1, y = x2)) +\n    geom_point(size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\nConstruya un modelo lineal multiple (con lm()) con ‘y’ como respuesta y ‘x1’ y ‘x2’ como predictores\nCompare los betas estimados por el modelo con los usados para generar los datos. ¿Es una buena estimación?. También observe los valores de p. ¿Esperaría que fueran significativos?"
  },
  {
    "objectID": "modelos_de_regresion.html#añadir-un-predictor-categórico",
    "href": "modelos_de_regresion.html#añadir-un-predictor-categórico",
    "title": "Modelos de regresión",
    "section": "1.5 Añadir un predictor categórico",
    "text": "1.5 Añadir un predictor categórico\nPara los predictores categóricos podemos crear primero una variable binaria (0, 1) y luego añadir etiquetas a cada valor:\n\n\nCódigo\n# definir semilla\nset.seed(13)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -3\nb1 &lt;- 2\nerror &lt;- rnorm(n = n, mean = 0, sd = 3)\n\n#  variables aleatorias\nx1_num &lt;- sample(0:1, size = n, replace = TRUE)\ny &lt;- b0 + b1 * x1_num + error\n\nx1 &lt;- factor(x1_num, labels = c(\"a\", \"b\"))\n\n# crear data frame\nxy_datos_cat &lt;- data.frame(x1, x1_num, y)\n\nhead(xy_datos_cat)\n\n\n\n\n\n\nx1\nx1_num\ny\n\n\n\n\nb\n1\n0.66298\n\n\na\n0\n-3.84082\n\n\na\n0\n2.32549\n\n\nb\n1\n-0.43804\n\n\na\n0\n0.42758\n\n\na\n0\n-1.75342\n\n\n\n\n\n\n \nY así es como se escribe formalmente:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1}\\)\n\n \nLo mismo que con los predictores continuos.\nPodemos explorar el patrón de los datos utilizando un diagrama de cajas (boxplot):\n\n\nCódigo\n# graficar\nggplot(xy_datos_cat, aes(x = x1, y = y)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n \n… y obtener los estimados del modelo:\n\n\nCódigo\n# construir modelos\nxy_mod_cat &lt;- lm(formula = y ~ x1, data = xy_datos_cat)\n\nsummary(xy_mod_cat)\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos_cat)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-5.898 -1.909 -0.094  1.809  5.506 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -2.997      0.558   -5.37  2.3e-06 ***\nx1b            1.814      0.842    2.16    0.036 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.95 on 48 degrees of freedom\nMultiple R-squared:  0.0882,    Adjusted R-squared:  0.0693 \nF-statistic: 4.65 on 1 and 48 DF,  p-value: 0.0362\n\n\n \n… graficar los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod_cat$coefficients), \n                    est = xy_mod_cat$coefficients, confint(xy_mod_cat))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n… y los gráficos diagnósticos del modelo:\n\n\nCódigo\nplot_model(xy_mod_cat, type = \"diag\")[[2]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -2.9974    0.55825 -5.3693 2.2677e-06\nx1b           1.8140    0.84160  2.1554 3.6172e-02\n\n\n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 1.814 y que es significativamente diferente de 0 (p = 0.03617)\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se fijó en 2 y se estimó como 1.814.\n\nTenga en cuenta que en este caso el intercepto se refiere a la estimación del nivel ‘a’ en el predictor categórico, que se utilizó como base:\n\n\n\nCódigo\n# graficar\nggplot(xy_datos_cat, aes(x = x1, y = y)) + \n  geom_boxplot() +\ngeom_hline(yintercept = xy_mod_cat$coefficients[1], col = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\n\nPor lo tanto, el intercepto es el mismo que la media de y para la categoría ‘a’:\n\n\n\nCódigo\nmean(xy_datos_cat$y[xy_datos_cat$x1 == \"a\"])\n\n\n[1] -2.9974\n\n\n\nObserve también que la etiqueta del estimado es ‘x1b’, no ‘x1’ como en los predictores continuos. Esto se debe a que en este caso el estimado se refiere a la diferencia entre los dos niveles de la variable categórica (‘a’ y ‘b’). Más concretamente, nos dice que en promedio las observaciones de la categoría ‘b’ son 1.814 más altas que las observaciones de la categoría ‘a’.\n\n \n\n \n\n\nCaso de estudio\n\n \n\nRico-Guevara A, & M Araya-Salas. 2015. Bills as daggers? A test for sexually dimorphic weapons in a lekking hummingbird species. Behavioral Ecology. 26 (1): 21-29.\n\n“Los machos con puntas de pico más grandes y puntiagudas tuvieron más éxito en ganar control de territorios en el lek.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 6\n \n\nLos datos desbalanceados cuando hay categorías (es decir, algunas categorías tienen muchas más observaciones que otras) pueden ser problemáticos para la inferencia estadística. Modifique el código arriba para simular un juego de datos muy desbalanceado y compruebe la precisión del modelo.\n\n\n\n\n\n\nVariables indicadoras (Dummy variables)\n\n\nEn un modelo de regresión, los predictores categóricos también se representan como vectores numéricos. Más concretamente, los predictores categóricos se codifican como 0s y 1s, en los que 1 significa “pertenece a la misma categoría” y 0 “pertenece a una categoría diferente”. Mantuvimos el vector numérico original (‘x1_num’) al simular el juego de datos con el predictor categórico:\n\n\nCódigo\nhead(xy_datos_cat)\n\n\n\n\n\n\nx1\nx1_num\ny\n\n\n\n\nb\n1\n0.66298\n\n\na\n0\n-3.84082\n\n\na\n0\n2.32549\n\n\nb\n1\n-0.43804\n\n\na\n0\n0.42758\n\n\na\n0\n-1.75342\n\n\n\n\n\n\nObserve que las “b” de la columna “x1” se convierten en 1 en la columna “x1_num” y las “a” se convierten en 0. Esto se denomina variable indicadora y el proceso se conoce como ‘codificación indicadora’ (dummy coding).\nEn realidad, podemos utilizar el vector numérico en el modelo de regresión y obtener exactamente los mismos resultados:\n\n\nCódigo\n# summary model with categorical variable\nsummary(xy_mod_cat)$coefficients\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -2.9974    0.55825 -5.3693 2.2677e-06\nx1b           1.8140    0.84160  2.1554 3.6172e-02\n\n\nCódigo\n# construir modelos with dummy variable\nxy_mod_num &lt;- lm(formula = y ~ x1_num, data = xy_datos_cat)\n\n# summary with dummy coding\nsummary(xy_mod_num)$coefficients\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -2.9974    0.55825 -5.3693 2.2677e-06\nx1_num        1.8140    0.84160  2.1554 3.6172e-02\n\n\n \nLas cosas se complican un poco más cuando se codifica un predictor categórico con más de dos niveles. Pero la lógica es la misma."
  },
  {
    "objectID": "modelos_de_regresion.html#interacciones",
    "href": "modelos_de_regresion.html#interacciones",
    "title": "Modelos de regresión",
    "section": "1.6 Interacciones",
    "text": "1.6 Interacciones\nUna interacción estadística se refiere a un efecto de una variable predictora que está mediado por una segunda variable.\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1} + \\beta_{2} * x_{2} + \\beta_{3} * x_{1} * x_{2}\\)\n\n \nEsto es más fácil de entender si se observa la interacción de una variable continua y una binaria:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- 1.7\nb3 &lt;- -3\nerror &lt;- rnorm(n = n, mean = 0, sd = 3)\n\n#  variables aleatorias\nx1 &lt;- rbinom(n = n, size = 1, prob = 0.5)\nx2 &lt;-  rnorm(n = n, mean = 0, sd = 1)\n\n# interaccion se añade como el producto dex1 y x2\ny &lt;- b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2 + error\n\nx1 &lt;- factor(x1, labels = c(\"a\", \"b\"))\n\n# crear data frame\nxy_datos_intr &lt;- data.frame(x1, x2, y)\n\nhead(xy_datos_intr)\n\n\n\n\n\n\nx1\nx2\ny\n\n\n\n\nb\n1.02557\n-4.0147\n\n\na\n-0.28477\n-5.1746\n\n\na\n-1.22072\n-1.3991\n\n\nb\n0.18130\n-1.0242\n\n\na\n-0.13889\n-3.8483\n\n\nb\n0.00576\n4.1377\n\n\n\n\n\n\nCódigo\n# construir modelos\nxy_mod_intr &lt;- lm(formula = y ~ x1 + x2 + x1 * x2, data = xy_datos_intr)\n\n# guardar resumen para graficar lineas de mejor ajuste\nxy_summ_intr &lt;- summary(xy_mod_intr)\n\nxy_summ_intr\n\n\n\nCall:\nlm(formula = y ~ x1 + x2 + x1 * x2, data = xy_datos_intr)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-6.222 -1.664 -0.158  1.650  6.383 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -4.193      0.570   -7.35  2.7e-09 ***\nx1b            3.597      0.806    4.46  5.2e-05 ***\nx2             1.327      0.682    1.95   0.0576 .  \nx1b:x2        -2.972      0.962   -3.09   0.0034 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.83 on 46 degrees of freedom\nMultiple R-squared:  0.396, Adjusted R-squared:  0.357 \nF-statistic:   10 on 3 and 46 DF,  p-value: 3.29e-05\n\n\nTambién ayuda graficar los datos:\n\n\nCódigo\n# graficar\nggplot(data = xy_datos_intr, aes(x = x2, y = y, color = x1)) +\n    geom_point(size = 3) +\n    geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n… y los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod_intr$coefficients), \n                    est = xy_mod_intr$coefficients, confint(xy_mod_intr))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \nTambién deberíamos revisar los gráficos de diagnóstico:\n\n\nCódigo\nplot_model(xy_mod_intr, type = \"diag\")\n\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n\n\n\n\n[[4]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes:\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -4.1930    0.57023 -7.3532 2.6978e-09\nx1b           3.5974    0.80607  4.4629 5.1950e-05\nx2            1.3274    0.68161  1.9474 5.7610e-02\nx1b:x2       -2.9720    0.96227 -3.0885 3.4061e-03\n\n\n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1-b’ a ‘x1-a’) es 3.59741 y que es significativamente diferente de 0 (valor p = 5.19496^{-5})\nEl modelo encontró que \\(\\beta_2\\) (el tamaño de efecto de ‘x2’) es 1.32735 y que es significativamente diferente de 0 (p = 0.05761). Esto es en realidad la pendiente de la relación entre x2 e y cuando x1 = `a’\nEl modelo encontró que \\(\\beta_3\\) (el tamaño de efecto del término de interacción ‘x1 * x2’) es -2.97196 y que es significativamente diferente de 0 (p = 0.00341). Esta es la diferencia entre las pendientes de x2 vs y cuando x1 = ‘a’ y x2 vs y cuando x1 = ‘b’.\nLos valores simulados para los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se simuló con un valor de 3 y se estimó en 3.597\n\\(\\beta_2\\) se simuló con un valor de 1.7 y se estimó en 1.327\n\\(\\beta_3\\) se simuló con un valor de -3 y se estimó en -2.972\n\n\n\n\n \n\n\nCaso de estudio\n\n \n\nChirino F, B Wilink, Araya-Salas M. In prep. Climatic factors affecting vocal activity in lemur leaf frogs.\n\n“El aumento de la luz de la luna disminuye la actividad vocal de Agalychnis lemur aunque esta relación es mediada por la temperatura.”"
  },
  {
    "objectID": "modelos_de_regresion.html#lectura-understanding-it-depends-in-ecology-a-guide-to-hypothesising-visualising-and-interpreting-statistical-interactions",
    "href": "modelos_de_regresion.html#lectura-understanding-it-depends-in-ecology-a-guide-to-hypothesising-visualising-and-interpreting-statistical-interactions",
    "title": "Modelos de regresión",
    "section": "Lectura: Understanding ‘it depends’ in ecology: a guide to hypothesising, visualising and interpreting statistical interactions",
    "text": "Lectura: Understanding ‘it depends’ in ecology: a guide to hypothesising, visualising and interpreting statistical interactions\nLos ecólogos utilizan habitualmente modelos estadísticos para detectar y explicar interacciones entre factores ecológicos, con el objetivo de evaluar si un efecto de interés cambia de signo o magnitud en distintos contextos. El artículo trata de los peligros de interpretan las interacciones estadísticas sin prestar atención a su propiedad fundamental de simetría, o a la escala de medida, ya sea aditiva o multiplicativa. Acá pueden acceder al artículo."
  },
  {
    "objectID": "modelos_de_regresion.html#modelos-lineales-generalizados-glm",
    "href": "modelos_de_regresion.html#modelos-lineales-generalizados-glm",
    "title": "Modelos de regresión",
    "section": "2.1 Modelos lineales generalizados (GLM)",
    "text": "2.1 Modelos lineales generalizados (GLM)\nLos GLM nos permiten modelar la asociación a variables respuesta que no siguen una distribución normal. Además, permiten modelar distribuciones que se asemejan más al proceso que generó los datos. El siguiente código crea un juego de datos con una respuesta que representa cuentas (por lo tanto, no normal):\n\n\nCódigo\n# Simulación de datos\nset.seed(123)  # Para reproducibilidad\nn &lt;- 100  # Número de observaciones\nx1 &lt;- rnorm(n)  # Predictor 1: variable normal\nx2 &lt;- rnorm(n)  # Predictor 2: variable normal\n\n# Coeficientes reales para la simulación\nb0 &lt;- 0.5  # Intercepto\nb1 &lt;- 1.2  # Coeficiente para x1\nb2 &lt;- -0.8  # Coeficiente para x2\n\n# Calcular lambda (tasa de eventos) utilizando la combinación lineal de los predictores\n# En el modelo de Poisson, la tasa esperada lambda está relacionada exponencialmente con los predictores\nlog_lambda &lt;- b0 + b1 * x1 + b2 * x2\nlambda &lt;- exp(log_lambda)  # Lambda debe ser positiva, por eso usamos exp()\n\n# Generar la variable respuesta (cuentas) a partir de la distribución de Poisson\ny &lt;- rpois(n, lambda)\n\n# Crear un data frame\nxy_datos_pois &lt;- data.frame(x1 = x1, x2 = x2, y = y)\n\n# Mostrar las primeras filas del data frame\nhead(xy_datos_pois)\n\n\n\n\n\n\nx1\nx2\ny\n\n\n\n\n-0.56048\n-0.71041\n5\n\n\n-0.23018\n0.25688\n0\n\n\n1.55871\n-0.24669\n17\n\n\n0.07051\n-0.34754\n2\n\n\n0.12929\n-0.95162\n4\n\n\n1.71506\n-0.04503\n15\n\n\n\n\n\n\nTambién grafiquemos ‘x1’ vs ‘y’:\n\n\nCódigo\n# graficar\nggplot(xy_datos_pois, aes(x = x1, y = y)) + \n  geom_point() \n\n\n\n\n\n\n\n\n\n \nLa relación no parece muy lineal ni la varianza parece ser constante a través de ‘x1’.\nPodemos relajar el requisito de la distribución normal con GLMs. glm() es una función básica de R que nos ayuda a hacer el truco. Para este ejemplo la distribución más apropiada es Poisson. Esto se puede establecer en el argumento `family’ así:\n\n\nCódigo\nglm_pois  &lt;- glm(formula = y ~ x1 + x2, data = xy_datos_pois, family = poisson())\n\n\n \nQue es equivalente a esto:\n\n\\(\\hat{Y} \\sim_{poisson} \\beta_{o} + \\beta_{1} * x_{1} + \\beta_{2} * x_{2}\\)\n\n \nComo puede ver el único argumento extra comparado con lm() es family. El resto es simplemente la “fórmula” y los “datos” con los que ya estamos familiarizados. Así que, de nuevo, podemos aprovechar nuestros conocimientos sobre los modelos lineales para extenderlos a estructuras de datos más complejas.\nTambién necesitamos ejecutar summary() para obtener el resultado del modelo:\n\n\nCódigo\nsummary(glm_pois)\n\n\n\nCall:\nglm(formula = y ~ x1 + x2, family = poisson(), data = xy_datos_pois)\n\nCoefficients:\n            Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)   0.4377     0.0867    5.05  4.4e-07 ***\nx1            1.2092     0.0565   21.40  &lt; 2e-16 ***\nx2           -0.8040     0.0582  -13.80  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 920.85  on 99  degrees of freedom\nResidual deviance: 110.28  on 97  degrees of freedom\nAIC: 347.4\n\nNumber of Fisher Scoring iterations: 5\n\n\n \n \n\n \n\nInterpretación del modelo\n\n \nCuadro de los coeficientes (estimados):\n\n\n            Estimate Std. Error  z value    Pr(&gt;|z|)\n(Intercept)  0.43769   0.086656   5.0509  4.3971e-07\nx1           1.20915   0.056501  21.4007 1.3161e-101\nx2          -0.80402   0.058242 -13.8049  2.3824e-43\n\n\n\nEl modelo nos dice que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 1.20915 y que es significativamente diferente de 0 (p = 1.31613^{-101}). Esto se interpreta en realidad como que un aumento de 1 unidad de ‘x1’ resulta en ‘y’ (tasa) en un factor de exp(1.20915) = 3.35064.\nEl modelo también nos dice que \\(\\beta_2\\) (el tamaño de efecto de ‘x2’) es -0.80402 y que es significativamente diferente de 0 (p = 2.38235^{-43}). Esto significa que un aumento en 1 unidad de ‘x2’ resulta en ‘y’ (tasa) en un factor de exp(-0.80402) = 0.44752.\n\n\n \n\n\nCaso de estudio\n\n \n\nTopp, E. N., Tscharntke, T., & Loos, J. (2022). Fire and landscape context shape plant and butterfly diversity in a South African shrubland. Diversity and Distributions, 28(3), 357-371.\n\n“La riqueza de especies de mariposas es de tres a cuatro veces mayor cuando aumenta el hábitat natural en el paisaje circundante (en un radio de 2 km), mientras que la abundancia de mariposas se asociaba negativamente con el aumento del tiempo transcurrido desde el último incendio.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 8\n\nIntente correr el modelo anterior lm() (con una distribución gaussiana), compare los resultados y compruebe los residuos (plot_model(model_name, type = \"diag\"))\n\n\nExisten muchas otras funciones de distribución y enlace:"
  },
  {
    "objectID": "modelos_de_regresion.html#modelos-de-efectos-variables-modelos-mixtos",
    "href": "modelos_de_regresion.html#modelos-de-efectos-variables-modelos-mixtos",
    "title": "Modelos de regresión",
    "section": "2.2 Modelos de efectos variables (modelos mixtos)",
    "text": "2.2 Modelos de efectos variables (modelos mixtos)\nA veces nuestros conjuntos de datos incluyen estructuras con varios niveles de organización. Por ejemplo, cuando tomamos muestras de varios individuos de diferentes poblaciones. En esos casos, la variación en el nivel estructural superior (poblaciones) podría impedir la detección de patrones en el nivel inferior (individuos).\nVamos a simular algunos datos que se asemejan a ese escenario. Tenemos dos predictores continuos (x1) y una respuesta continua (y). Cada muestra procede de 1 de 8 poblaciones diferentes (poblacion):\n\n\nCódigo\n# x&lt;- 1\n# definir semilla\nset.seed(28)\n\n# numero de observaciones\nn &lt;- 300\nb0 &lt;- 1\nb1 &lt;- 1.3\npoblacion &lt;- sample(0:8, size = n, replace = TRUE)\nerror &lt;- rnorm(n = n, mean = 0, sd = 2)\n\n#  variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + poblacion * 2 + b1 * x1 + error\n\n# add letters\npoblacion &lt;- letters[poblacion + 1]\n\n# create data set\nxy_datos_mixto &lt;- data.frame(x1, y, poblacion)\n\nhead(xy_datos_mixto, 10)\n\n\n\n\n\n\nx1\ny\npoblacion\n\n\n\n\n1.54607\n3.3378\na\n\n\n0.56834\n3.1399\na\n\n\n-0.63855\n15.2824\ni\n\n\n0.98424\n2.6610\na\n\n\n1.05355\n3.7312\nb\n\n\n-0.82294\n3.0189\na\n\n\n-1.32373\n3.2186\nc\n\n\n2.17854\n19.0542\ni\n\n\n2.26484\n15.4549\ni\n\n\n-0.77843\n11.6670\nh\n\n\n\n\n\n\n \nPodemos explorar la relación entre ‘y’ y ‘x1’ con un gráfico:\n\n\nCódigo\nggplot(data = xy_datos_mixto, aes(x = x1, y = y)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n \n¿Puede ver claramente el patrón de asociación entre las dos variables que hemos utilizado para simular los datos? Podemos seguir explorando los datos con un modelo de regresión lineal simple:\n\n\nCódigo\nsummary(lm(y ~ x1, data = xy_datos_mixto))\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos_mixto)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-11.755  -5.119   0.186   4.602  12.409 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    8.852      0.325   27.21   &lt;2e-16 ***\nx1             0.633      0.329    1.92    0.055 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.63 on 298 degrees of freedom\nMultiple R-squared:  0.0123,    Adjusted R-squared:  0.00895 \nF-statistic:  3.7 on 1 and 298 DF,  p-value: 0.0554\n\n\n \nA pesar de haber simulado un \\(\\beta_1\\) distinto de cero, no tenemos ninguna asociación significativa según este modelo y la estimación de \\(\\beta_1\\) está muy lejos de la simulada. Esta pobre inferencia se debe a que estamos ignorando una característica importante de nuestros datos, la agrupación de las muestras en “poblaciones”.\nLos modelos de efectos mixtos (también conocidos como modelos multinivel o modelos de efectos variables) pueden ayudarnos a tener en cuenta estas características adicionales, mejorando significativamente nuestro poder de inferencia. Coloreemos cada una de las poblaciones para ver cómo covarían las variables en cada subgrupo de datos:\n\n\nCódigo\nggplot(data = xy_datos_mixto, aes(x = x1, y = y, color = poblacion)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n \nParece haber un patrón claro de asociación positiva entre x1 e y. El patrón se hace un poco más evidente si mostramos cada población en su propio panel:\n\n\nCódigo\nggplot(data = xy_datos_mixto, aes(x = x1, y = y, color = poblacion)) +\n  geom_point() +\n  facet_wrap( ~ poblacion) +\n  geom_smooth(method = \"lm\", se = FALSE) \n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nConstruyamos un modelo de efectos mixtos utilizando la población como intercepto variable:\n\n\nCódigo\nmix_eff_mod &lt;- lmer(formula = y ~ x1 + (1 | poblacion), data = xy_datos_mixto)\n\n\nQue es equivalente a esto:\n\n\\(\\hat{Y} \\sim_{gausiana} (\\beta_{o} + \\beta_{grupo}) + \\beta_{1} * x_{1}\\)\n\n \nPodemos ver el resultado del modelo igual que con un modelo lm():\n\n\nCódigo\nsummary(mix_eff_mod)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: y ~ x1 + (1 | poblacion)\n   Data: xy_datos_mixto\n\nREML criterion at convergence: 1296.4\n\nScaled residuals: \n   Min     1Q Median     3Q    Max \n-3.524 -0.657 -0.032  0.612  3.245 \n\nRandom effects:\n Groups    Name        Variance Std.Dev.\n poblacion (Intercept) 30.07    5.48    \n Residual               3.76    1.94    \nNumber of obs: 300, groups:  poblacion, 9\n\nFixed effects:\n            Estimate Std. Error      df t value Pr(&gt;|t|)    \n(Intercept)    8.788      1.831   8.003     4.8   0.0014 ** \nx1             1.317      0.115 290.068    11.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n   (Intr)\nx1 -0.003\n\n\n \nEl modelo detectó correctamente el patrón simulado y la estimación de \\(\\beta_1\\) (1.317) es muy cercana al valor simulado.\n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error       df t value   Pr(&gt;|t|)\n(Intercept)   8.7881     1.8315   8.0031  4.7983 1.3569e-03\nx1            1.3166     0.1151 290.0679 11.4395 2.9326e-25\n\n\n \n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 1.31665 y que es significativamente diferente de 0 (p = 2.93263^{-25})\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lmer() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se fijó en 1.3 y se estimó como 1.317.\n\nLa varianza del intercepto para cada población fue de 29.95624 y la desviación estándar de 5.47323\nLos interceptos estimados para cada población son:\n\n\n\nCódigo\nranef(mix_eff_mod)$poblacion\n\n\n\n\n\n\n\n(Intercept)\n\n\n\n\na\n-8.22835\n\n\nb\n-6.17134\n\n\nc\n-4.23048\n\n\nd\n-1.30838\n\n\ne\n0.24573\n\n\nf\n2.22552\n\n\ng\n3.91556\n\n\nh\n5.75609\n\n\ni\n7.79566\n\n\n\n\n\n\n \n\nPodemos compararlos con los promedios para cada población en los datos:\n\n\n\nCódigo\n# sumar interceptos por poblacion a el intercepto total\ninterceptos &lt;- ranef(mix_eff_mod)$poblacion + fixef(mix_eff_mod)[1]\n\n# calcular los promedios por poblacion en los datos \nprom_pobs &lt;- aggregate(y ~ poblacion, xy_datos_mixto, mean)\n\n# unir\ncbind(interceptos, prom_pobs= prom_pobs[,2])\n\n\n\n\n\n\n\n(Intercept)\nprom_pobs\n\n\n\n\na\n0.55975\n0.86151\n\n\nb\n2.61677\n2.76860\n\n\nc\n4.55762\n4.90112\n\n\nd\n7.47972\n7.73174\n\n\ne\n9.03384\n8.87649\n\n\nf\n11.01363\n10.77650\n\n\ng\n12.70366\n12.62651\n\n\nh\n14.54420\n14.62110\n\n\ni\n16.58376\n16.42520\n\n\n\n\n\n\n \n\nLa varianza entre los niveles del factor aleatorio (poblacion) es de 29.95624 y la desviación estándar de 5.47323\n\n \n\n\n\nCaso de estudio\n\n\nAraya-Salas M, P González-Gómez, K Wojczulanis-Jakubas, V López III & T Wright. 2018. Spatial memory is as important as weapon and body size for territorial ownership in a lekking hummingbird. Scientific Reports. 13, e0189969\n\n“… el tamaño corporal mostró una correlación negativa con la frecuencia baja del canto.”\n\n\n\n\n\n\n\n\n\n \n\n\n2.2.1 La paradoja de Simpson\nLa paradoja de Simpson es un fenómeno en estadística en el que una tendencia aparece en varios grupos de datos pero desaparece o se invierte cuando se combinan los grupos. Se ha utilizado para ilustrar el tipo de resultados engañosos que puede generar el ignorar la estructura en los datos y las relaciones causales entre variables.\n\n\n\n\n\n\n\n\n\nTomado de wikipedia\n \nLa estructura de los datos debido a observaciones pertenecientes al mismo grupo puede ser tomada en cuenta usando el grupo como un factor aleatorio, tal y como se hizo en el ejemplo anterior.\n \n\n\nModelos lineales como abordaje estadístico estándar para la inferencia causal \n\n\n\n\n\n\n\n\n\n\n\n\\(\\hat{Y} \\sim_{función\\ de\\ enlace} (\\beta_{o} + \\beta_{grupo}) + \\beta_{1} * x_{1} + \\cdots + \\beta_{n} * x_{n}\\)\n\n\nEste modelo básico incluye una función de enlace que cuando es gausiana (i.e. normal) equivale a un modelo lineal y cuando no, a un modelo generalizado\nCuando el \\(\\beta_{grupo}\\) es diferente entre grupos (i.e. cuando el intercepto difiere entre grupos) es un modelo mixto con intercepto variable (i.e. aleatorio)\n\n \n\n \nEste manual solo pretende sugerir un abordaje estadístico centrado en los modelos de regresión desde el cual se pueden llevar a cabo adecuadamente la mayoría de los análisis estadísticos que usamos en investigación. El manual no tiene como objetivo explicar en detalle las particularidades de los modelos generalizados y mixtos. Note que estos modelos, principalmente los mixtos, pueden adaptarse a otras estructuras de datos mas complejas no cubiertas aquí, como lo son las pendientes aleatorias, pendientes e interceptos aleatorios, estructuras de correlación (i.e. autocorrelación espacial o temporal, pedigrís o árboles filogenéticos), medidas repetidas y el uso de pseudoreplicas, entre otras."
  },
  {
    "objectID": "modelos_de_regresion.html#referencias",
    "href": "modelos_de_regresion.html#referencias",
    "title": "Modelos de regresión",
    "section": "2.3 Referencias",
    "text": "2.3 Referencias\n\nRichard McElreath’s Statistical Rethinking book\nSpake, R., Bowler, D. E., Callaghan, C. T., Blowes, S. A., Doncaster, C. P., Antao, L. H., … & Chase, J. M. (2023). Understanding ‘it depends’ in ecology: a guide to hypothesising, visualising and interpreting statistical interactions. Biological Reviews.\nComplete introduction to linear regression in R\nLinear regression in R\nHarrison, X. A., Donaldson, L., Correa-Cano, M. E., Evans, J., Fisher, D. N., Goodwin, C. E., & Inger, R. (2018). A brief introduction to mixed effects modelling and multi-model inference in ecology. PeerJ, 6, e4794."
  },
  {
    "objectID": "instructor.html",
    "href": "instructor.html",
    "title": "",
    "section": "",
    "text": "Código\n\n\n\n\n\nMarcelo Araya-Salas\n\n\n\n\n\nUn ecólogo del comportamiento mas que acabó haciendo mucha programación solo para poder hacer bien el análisis de datos. Ademas de la investigación, también trabajo en hacer herramientas computacionales para el análisis de datos biológicos (no genéticos), principalmente relacionados con el comportamiento animal y la bioacústica. Soy el desarrollador de los paquetes de R warbleR y Rraven los cuales tienen funciones para agilizar el análisis acústico de sonidos de los animales. Más recientemente, sacamos los paquetes baRulho, para cuantificar la transmisión y la degradación de la señal acústica, ohun, para optimizar la detección automática y PhenotypeSpace para cuantificar los espacios de rasgos multidimensionales. Recientemente también desarrollé el paquete sketchy para organizar compendios de investigación."
  },
  {
    "objectID": "como_simular_datos.html",
    "href": "como_simular_datos.html",
    "title": "Simulación de datos",
    "section": "",
    "text": "Paquetes a utilizar en este manual:\nCódigo\n# instalar/cargar paquetes\n\nsketchy::load_packages(\n  c(\"ggplot2\", \n    \"viridis\"\n    )\n  )"
  },
  {
    "objectID": "como_simular_datos.html#generación-de-números-aleatorios-en-r",
    "href": "como_simular_datos.html#generación-de-números-aleatorios-en-r",
    "title": "Simulación de datos",
    "section": "1.1 Generación de números aleatorios en R",
    "text": "1.1 Generación de números aleatorios en R\nLa estadística nos permite inferir patrones en los datos. Solemos utilizar conjuntos de datos reales para enseñar estadística. Sin embargo, puede ser circular entender el funcionamiento interno de una herramienta estadística probando su capacidad para inferir un patrón que no estamos seguros de encontrar en los datos (y no tenemos idea del mecanismo que produjo ese patrón). Las simulaciones nos permiten crear escenarios controlados en los que conocemos con seguridad los patrones presentes en los datos y los procesos subyacentes que los han generado.\nR ofrece algunas funciones básicas para la simulación de datos. Las más utilizadas son las funciones generadoras de números aleatorios. Los nombres de estas funciones comienzan con r (r____()). Por ejemplo, runif():\n\n\nCódigo\n# simular variable uniforme\nunif_var &lt;- runif(n = 100, min = 0, max = 10)\n\n\n \nEl resultado es un vector numérico de longitud 100 (n = 100):\n\n\nCódigo\n# imprimir variable\nunif_var\n\n\n  [1] 9.889093 3.977455 1.156978 0.697487 2.437494 7.920104 3.400624 9.720625\n  [9] 1.658555 4.591037 1.717481 2.314771 7.728119 0.963015 4.534478 0.847007\n [17] 5.606659 0.087046 9.857371 3.165848 6.394489 2.952232 9.967037 9.060213\n [25] 9.887391 0.656457 6.270388 4.904750 9.710244 3.622208 6.799935 2.637199\n [33] 1.857143 1.851432 3.792967 8.470244 4.980761 7.905856 8.384639 4.569039\n [41] 7.994758 3.819431 7.597012 4.367756 9.042177 3.195349 0.825691 8.162891\n [49] 8.984762 9.664964 5.730689 7.200795 7.740586 6.277608 7.229893 3.868313\n [57] 1.627908 1.872283 3.912495 2.739012 1.919177 5.043918 7.638404 6.936689\n [65] 5.440542 6.590872 4.687284 4.818055 3.370636 4.245263 2.870151 6.011915\n [73] 8.407423 6.208370 1.345516 5.677224 4.434263 4.379754 6.236172 9.326533\n [81] 8.884926 8.785406 2.421769 7.414538 3.876563 0.789517 0.948356 7.621427\n [89] 3.478940 4.167667 3.440162 0.084109 9.115750 1.822054 7.228034 5.719633\n [97] 5.400364 3.549474 8.240918 1.861368\n\n\n \nPodemos explorar el resultado graficando un histograma:\n\n\nCódigo\n# crear histograma\nggplot(data = data.frame(unif_var), mapping = aes(x = unif_var)) + geom_histogram()\n\n\n\n\n\n\n\n\n\n \nMuestra una distribución uniforme que va de 0 a 10.\nTambién podemos simular números aleatorios procedentes de una distribución normal utilizando rnorm():\n\n\nCódigo\n# crear una variable normal\nnorm_var &lt;- rnorm(n = 1000, mean = 2, sd = 1)\n\n# graficar histograma\nggplot(data = data.frame(norm_var), mapping = aes(x = norm_var)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que todas las funciones generadoras de números aleatorios tienen el argumento ‘n’, que determina la longitud del vector generado (es decir, el número de números aleatorios), además de algunos argumentos adicionales relacionados con parámetros específicos de la distribución.\nLas variables continuas (es decir, los vectores numéricos) pueden convertirse en variables discretas (es decir, números enteros) simplemente redondeándolas:\n\n\nCódigo\nv1 &lt;- rnorm(n = 5, mean = 10, sd = 3)\n\nv1\n\n\n[1] 15.4269  8.5450 15.1387  8.9203  9.3693\n\n\nCódigo\nround(x = v1, digits = 0)\n\n\n[1] 15  9 15  9  9\n\n\n \n\nEjercicio 1\n\n¿Qué hacen las funciones rbinom() y rexp()?\nEjecútela y haga histogramas de sus resultados\n¿Qué hacen los argumentos ‘mean’ y ‘sd’ en rnorm()? Juegue con diferentes valores y comprueba el histograma para hacerse una idea de su efecto en la simulación"
  },
  {
    "objectID": "como_simular_datos.html#generación-de-variables-categóricas",
    "href": "como_simular_datos.html#generación-de-variables-categóricas",
    "title": "Simulación de datos",
    "section": "1.2 Generación de variables categóricas",
    "text": "1.2 Generación de variables categóricas\nLa forma más sencilla de generar variables categóricas es utilizar el vector de ejemplo letters' (oLETTERS’) para asignar niveles de categoría. Podemos hacerlo utilizando la función rep(). Por ejemplo, el siguiente código crea un vector categórico (caracteres) con dos niveles, cada uno con 4 observaciones:\n\n\nCódigo\nrep(letters[1:2], each = 4)\n\n\n[1] \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\"\n\n\n \nTambién podemos replicar este patrón utilizando el argumento ‘times’. Este código replica el vector anterior 2 veces:\n\n\nCódigo\nrep(letters[1:2], each = 4, times = 2)\n\n\n [1] \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\" \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\"\n\n\n \nOtra opción es simular una variable a partir de una distribución binomial y luego convertirla en un factor:\n\n\nCódigo\n# correr rbinom\nbinom_var &lt;- rbinom(n = 50, size = 1, prob = 0.5)\n\nbinom_var\n\n\n [1] 1 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 0 0\n[39] 1 1 0 0 0 0 0 1 0 1 1 1\n\n\n\n\nCódigo\n# convertir a factor\ncateg_var &lt;- factor(binom_var, labels = c(\"a\", \"b\"))\n\ncateg_var\n\n\n [1] b a a b b a a a a a a a b b b a a b a b a a a a a a a b a b b b a a a b a a\n[39] b b a a a a a b a b b b\nLevels: a b"
  },
  {
    "objectID": "como_simular_datos.html#muestreo-aleatorio",
    "href": "como_simular_datos.html#muestreo-aleatorio",
    "title": "Simulación de datos",
    "section": "1.3 Muestreo aleatorio",
    "text": "1.3 Muestreo aleatorio\nLa otra herramienta importante de R para jugar con datos simulados es sample(). Esta función permite tomar muestras de tamaños específicos de vectores. Por ejemplo, tomemos el ejemplo del vector ‘letters’:\n\n\nCódigo\nletters\n\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n \nPodemos tomar una muestra de este vector como es:\n\n\nCódigo\n# tomar muestra\nsample(x = letters, size = 10)\n\n\n [1] \"i\" \"r\" \"q\" \"a\" \"c\" \"m\" \"y\" \"z\" \"u\" \"v\"\n\n\n \nEl argumento ‘size’ nos permite determinar el tamaño de la muestra. Tenga en cuenta que obtendremos un error si el tamaño es mayor que el propio vector:\n\n\nCódigo\nsample(x = letters, size = 30)\n\n\nError in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n\n\n \nEsto sólo puede hacerse cuando el muestreo es con reemplazo (replacement). El muestreo con reemplazo puede aplicarse estableciendo el argumento replace = TRUE:\n\n\nCódigo\nsample(x = letters, size = 30, replace = TRUE)\n\n\n [1] \"j\" \"i\" \"h\" \"i\" \"k\" \"u\" \"n\" \"i\" \"w\" \"k\" \"c\" \"t\" \"m\" \"p\" \"i\" \"h\" \"d\" \"w\" \"c\"\n[20] \"q\" \"j\" \"e\" \"e\" \"j\" \"k\" \"c\" \"l\" \"t\" \"r\" \"h\""
  },
  {
    "objectID": "como_simular_datos.html#iterar-un-proceso",
    "href": "como_simular_datos.html#iterar-un-proceso",
    "title": "Simulación de datos",
    "section": "1.4 Iterar un proceso",
    "text": "1.4 Iterar un proceso\nA menudo, las simulaciones deben repetirse varias veces para descartar resultados espurios debidos al azar o simplemente para probar diferentes parámetros. Las funciones de simulación de datos mencionadas anteriormente pueden ejecutarse varias veces (por ejemplo, iteradas) utilizando la función replicate():\n\n\nCódigo\n# replicar\nrepl_rnorm &lt;- replicate(n = 3, expr = rnorm(2), simplify = FALSE)\n\n# ver clase\nclass(repl_rnorm)\n\n\n[1] \"list\"\n\n\nCódigo\n# imprimir\nrepl_rnorm\n\n\n[[1]]\n[1]  1.19184 -0.33992\n\n[[2]]\n[1]  0.78911 -0.63213\n\n[[3]]\n[1] -1.49312 -0.13441"
  },
  {
    "objectID": "como_simular_datos.html#hacer-que-las-simulaciones-sean-reproducibles",
    "href": "como_simular_datos.html#hacer-que-las-simulaciones-sean-reproducibles",
    "title": "Simulación de datos",
    "section": "1.5 Hacer que las simulaciones sean reproducibles",
    "text": "1.5 Hacer que las simulaciones sean reproducibles\nEl último truco que necesitamos para ejecutar simulaciones en R es la capacidad de reproducir una simulación (es decir, obtener exactamente los mismos datos y resultados simulados). Esto puede ser útil para que otros investigadores puedan ejecutar nuestros análisis exactamente de la misma manera. Esto puede hacerse fácilmente con la función set.seed(). Pruebe a ejecutar el siguiente código. Debería obtener la misma salida:\n\n\nCódigo\n# definir semilla\nset.seed(10)\n\n# crear variable uniforme\nrunif(n = 2)\n\n\n[1] 0.50748 0.30677"
  },
  {
    "objectID": "como_simular_datos.html#juegos-de-datos-con-variables-numéricas-y-categóricas",
    "href": "como_simular_datos.html#juegos-de-datos-con-variables-numéricas-y-categóricas",
    "title": "Simulación de datos",
    "section": "2.1 Juegos de datos con variables numéricas y categóricas",
    "text": "2.1 Juegos de datos con variables numéricas y categóricas\nAhora que sabemos cómo simular variables continuas y categóricas. Podemos juntarlas para crear conjuntos de datos simulados. Esto se puede hacer utilizando la función data.frame():\n\n\nCódigo\n# crear variable categorica\ngrupo &lt;- rep(letters[1:2], each = 3)\n\n# crear variable continuaa\ntamano &lt;- rnorm(n = 6, mean = 5, sd = 1)\n\n# poner juntas en un data frame\ndf &lt;- data.frame(grupo, tamano)\n\n# imprimir\ndf\n\n\n\n\n\n\ngrupo\ntamano\n\n\n\n\na\n4.8158\n\n\na\n3.6287\n\n\na\n4.4008\n\n\nb\n5.2946\n\n\nb\n5.3898\n\n\nb\n3.7919\n\n\n\n\n\n\nPor supuesto, podríamos añadir más variables a este cuadro de datos:\n\n\nCódigo\n# crear variable categorica\ngrupo &lt;- rep(letters[1:2], each = 3)\nindividuo &lt;- rep(LETTERS[1:6])\n\n# crear variables continuas\ntamano &lt;- rnorm(n = 6, mean = 5, sd = 1)\npeso &lt;- rnorm(n = 6, mean = 100, sd = 10)\n\n# poner todo en un data frame\ndf &lt;- data.frame(grupo, individuo, tamano, peso)\n\n# imprimir\ndf\n\n\n\n\n\n\ngrupo\nindividuo\ntamano\npeso\n\n\n\n\na\nA\n4.6363\n109.874\n\n\na\nB\n3.3733\n107.414\n\n\na\nC\n4.7435\n100.893\n\n\nb\nD\n6.1018\n90.451\n\n\nb\nE\n5.7558\n98.049\n\n\nb\nF\n4.7618\n109.255\n\n\n\n\n\n\nY eso es un juego de datos simulados en su forma más básica. Se parece mucho al tipo de datos con los que trabajamos en biología."
  },
  {
    "objectID": "como_simular_datos.html#prueba-de-concepto-el-teorema-del-límite-central",
    "href": "como_simular_datos.html#prueba-de-concepto-el-teorema-del-límite-central",
    "title": "Simulación de datos",
    "section": "3.1 Prueba de concepto: el Teorema del Límite Central",
    "text": "3.1 Prueba de concepto: el Teorema del Límite Central\nEl Teorema del Límite Central afirma que, si tomamos muestras aleatorias de una población, los promedios de esas muestras seguirán una distribución normal, aunque la población no esté distribuida normalmente. Además, la distribución normal resultante debe tener un promedio cercano al promedio de la población. El teorema es un concepto clave para la estadística inferencial, ya que implica que los métodos estadísticos que funcionan para las distribuciones normales pueden ser aplicables a muchos problemas que implican otros tipos de distribuciones. No obstante, el objetivo aquí es sólo mostrar cómo se pueden utilizar las simulaciones para entender el comportamiento de los métodos estadísticos.\nPara comprobar si esas afirmaciones básicas sobre el Teorema del Límite Central son ciertas, podemos utilizar datos simulados en R. Vamos a simular una población de 1000 observaciones con una distribución uniforme:\n\n\nCódigo\n# simular popublacion uniforme\nunif_pop &lt;- runif(1000, min = 0, max = 10)\n\n# ver histograma\nggplot(data = data.frame(unif_pop), mapping = aes(x = unif_pop)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n \nPodemos tomar muestras aleatorias usando sample() así:\n\n\nCódigo\nsample(x = unif_pop, size = 30)\n\n\n [1] 9.28420 1.02626 2.57517 3.32485 6.89990 2.29404 0.33737 8.21366 3.30364\n[10] 8.03793 2.59174 7.81770 5.65426 0.63831 2.83470 4.20434 4.76330 4.42193\n[19] 6.97830 7.92625 0.68121 3.52323 6.51103 5.38289 7.97210 1.80062 4.21282\n[28] 3.33866 8.91223 4.71163\n\n\n \nEste proceso puede ser replicado varias veces con replicate():\n\n\nCódigo\n# replicar\nsamples &lt;- replicate(n = 100, expr = mean(sample(x = unif_pop, size = 30)))\n\n\n \nEl código anterior toma 100 muestras con 30 valores cada una. Ahora podemos comprobar la distribución de las muestras:\n\n\nCódigo\n# ver distribucion/ histograma\nggplot(data = data.frame(samples), mapping = aes(x = samples)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n \n… asi como el promedio:\n\n\nCódigo\nmean(samples)\n\n\n[1] 5.0212\n\n\n \nComo era de esperar, las muestras siguen una distribución normal con una media cercana a la media de la población, que es:\n\n\nCódigo\nmean(unif_pop)\n\n\n[1] 5.0527\n\n\n \nProbemos con una distribución más compleja. Por ejemplo, una distribución bimodal:\n\n\nCódigo\n# usar semilla\nset.seed(123)\n\n# simular variables\nnorm1 &lt;- rnorm(n = 1000, mean = 10, sd = 3)\nnorm2 &lt;- rnorm(n = 1000, mean = 20, sd = 3)\n\n# juntar en una sola variable\nbimod_pop &lt;- c(norm1, norm2)\n\n# ver histograma\nggplot(data = data.frame(bimod_pop), mapping = aes(x = bimod_pop)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# replicar muestreo\nsamples &lt;- replicate(200, mean(sample(bimod_pop, 10)))\n\n# ver histograma\nggplot(data = data.frame(samples), mapping = aes(x = samples)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# ver promedios\nmean(samples)\n\n\n[1] 15.231\n\n\nCódigo\nmean(bimod_pop)\n\n\n[1] 15.088\n\n\n \n\nEjercicio 2\n \n\nIntenta explorar el Teorema del Límite Central como en el caso anterior, pero esta vez utilizando:\n\nUna distribución exponencial (rexp())\nUna distribución log-normal (rlnorm())\n\n\n \n\nPara cada distribución: grafique un histograma y compare los promedios de la población y de las muestras"
  },
  {
    "objectID": "como_simular_datos.html#referencias",
    "href": "como_simular_datos.html#referencias",
    "title": "Simulación de datos",
    "section": "3.2 Referencias",
    "text": "3.2 Referencias\n\nR’s rbinom – Simulate Binomial or Bernoulli trials\nR’s rnorm – selecting values from a normal distribution\nR’s exp – Simulating Exponential Distributions\nSimulating data in R"
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "Gráficos con ggplot2",
    "section": "",
    "text": "Comprender la lógica detras de la estructura los gráficos con ggplot2\nSer capaz de intregrar en un gŕafico diferentes fuentes de información que representen la complejidad de los datos"
  },
  {
    "objectID": "ggplot2.html#ggplot2",
    "href": "ggplot2.html#ggplot2",
    "title": "Gráficos con ggplot2",
    "section": "ggplot2",
    "text": "ggplot2\n\nUn paquete de R diseñado específicamente para producir gráficos\nA diferencia de otros paquetes, ggplot2 tiene su propia gramática\nLa gramática se basa en la “Gramática de los gráficos” (Wilkinson 2005)\nMódulos independientes que pueden combinarse de muchas formas\nEsta gramática proporciona una gran flexibilidad"
  },
  {
    "objectID": "ggplot2.html#gramática-de-gráficos",
    "href": "ggplot2.html#gramática-de-gráficos",
    "title": "Gráficos con ggplot2",
    "section": "0.1 Gramática de gráficos",
    "text": "0.1 Gramática de gráficos\nLa idea principal es empezar con una capa base de datos brutos y luego añadir más capas de anotaciones y resúmenes estadísticos. El paquete nos permite producir gráficos utilizando la misma estructura de pensamiento que utilizamos al diseñar un análisis, reduciendo la distancia de cómo visualizamos un gráfico en la cabeza y el producto final.\nAprender la gramática no sólo es útil para producir un gráfico de interés, sino también para pensar en otros gráficos más complejos. La ventaja de esta gramática es la posibilidad de crear nuevos gráficos compuestos por nuevas combinaciones de elementos."
  },
  {
    "objectID": "ggplot2.html#componentes-del-gráfico",
    "href": "ggplot2.html#componentes-del-gráfico",
    "title": "Gráficos con ggplot2",
    "section": "0.2 Componentes del gráfico",
    "text": "0.2 Componentes del gráfico\nTodos los gráficos ggplot2 contienen los siguientes componentes:\n\nDatos - El objeto R con la información que necesita ser trazada\nCapas - Los datos específicos que serán graficados (ej. ‘x’ & ‘y’)\nEscala - Rango de datos a incluir\nCoordenadas - Sistema de coordenadas (no se utiliza muy a menudo)\nParcelas (facets) - Determina cómo dividir los datos en subparcelas en un multipanel\nTema - Controla el estilo del gráfico\n\n \nEstos componentes se juntan utilizando “+”.\nLa sintaxis más habitual incluye los datos dentro de la llamada “ggplot” y una capa “geom_”.\n \nPrimero instala/carga el paquete:\n\n\nCódigo\n# install\ninstall.packages(\"ggplot2\")\n\n# load library\nlibrary(ggplot2)"
  },
  {
    "objectID": "ggplot2.html#gráficos-de-dispersión",
    "href": "ggplot2.html#gráficos-de-dispersión",
    "title": "Gráficos con ggplot2",
    "section": "0.3 Gráficos de dispersión",
    "text": "0.3 Gráficos de dispersión\nUtilicemos el conjunto de datos “iris” para crear gráficos de dispersión:\n\n\nCódigo\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n \nThis plot is defined by 3 components: 1. “data”- iris 1. “aes” - Sepal.length vs Petal.length 1. “layer” - Points (geom)"
  },
  {
    "objectID": "ggplot2.html#atributos-estéticos",
    "href": "ggplot2.html#atributos-estéticos",
    "title": "Gráficos con ggplot2",
    "section": "0.4 Atributos estéticos",
    "text": "0.4 Atributos estéticos\nTambién podemos añadir otros atributos estéticos como el color, la forma y el tamaño. Estos atributos se pueden incluir dentro de aes():\n\n\nCódigo\n# color by species\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nCódigo\n# color and shape by species\nggplot(\n  data = iris,\n  mapping = aes(\n    x = Sepal.Length,\n    y = Petal.Length,\n    color = Species,\n    shape = Species\n  )\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que los argumentos estéticos también pueden incluirse en la capa “geom”:\n\n\nCódigo\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length)\n) +\n  geom_point(aes(color = Species, shape = Species))\n\n\n\n\n\n\n\n\n\n \nTambién podemos incluir un valor fijo:\n\n\nCódigo\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length)\n) +\n  geom_point(color = \"red2\")\n\n\n\n\n\n\n\n\n\n \nAlgunos atributos funcionan mejor con algunos tipos de datos:\n\nColor y forma: variables categóricas\nTamaño: variables continuas\n\n \n\n\nEjercicio 1\nUtilizando el conjunto de datos “hylaeformis”:\n\n\nCódigo\n# lear desde el sitio del curso\nhylaeformis_data &lt;- read.csv(\n  paste0(\"https://raw.githubusercontent.com/maRce10/\", \"r_avanzado_2023/master/data/hylaeformis_data.csv\")\n)\n\n# or bajar manualmente y leer copia local\nhylaeformis_data &lt;- read.csv(\"hylaeformis_data.csv\", stringsAsFactors = FALSE)\n\nhead(hylaeformis_data, 20)\n\n\n\n1.1 Create a scatter plot of vs “meanfreq” (mean frequency)\n1.1 Crear un gráfico de dispersión de duración (“duration”) vs frecuencia promedio (“meanfreq”)\n\n1.2 Añadir un atributo estético para mostrar un color diferente para cada localidad\n\n1.3 Añade otro atributo estético para mostrar el rango de frecuencia dominante (“dfrange”) como tamaño los símbolos"
  },
  {
    "objectID": "ggplot2.html#gráficos-multipanel-facetting",
    "href": "ggplot2.html#gráficos-multipanel-facetting",
    "title": "Gráficos con ggplot2",
    "section": "0.5 Gráficos multipanel (Facetting)",
    "text": "0.5 Gráficos multipanel (Facetting)\n\nOtra forma de visualizar variables categóricas\nPermite crear gráficos multipanel para cada nivel de la variable\n2 tipos: “grid” & “wrap”\n\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species)\n\n\n\n\n\n\n\n\n\nCódigo\n# o\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_grid(~Species)\n\n\n\n\n\n\n\n\n\n \nLa escala puede ser fija o libre para los ejes x e y, y puede modificarse el número de columnas y filas:\n\n\nCódigo\n# free x\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free_x\")\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# free x and 3 rows\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free_y\", nrow = 3)\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# both free and 2 rows\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free\", nrow = 2)\n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que también podemos guardar el componente básico como un objeto R y añadir otros componentes más adelante en el código:\n\n\nCódigo\np &lt;- ggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\np + facet_wrap(~Species, scales = \"free_x\", nrow = 3)"
  },
  {
    "objectID": "ggplot2.html#geoms-adicionales",
    "href": "ggplot2.html#geoms-adicionales",
    "title": "Gráficos con ggplot2",
    "section": "0.6 “geoms” adicionales",
    "text": "0.6 “geoms” adicionales\n\ngeom_smooth() - añade las líneas de mejor ajuste (incluyendo CI)\ngeom_boxplot() - Distribución de frecuencias\ngeom_histogram() & geom_freqpoly() - distribuciones de frecuencia\ngeom_bar() - distribución de frecuencias de variables categóricas\ngeom_path() & geom_line() - añade líneas a los gráficos de dispersión\n\n \n\n0.6.1 geom_smooth()\nLas líneas de regresión de mejor ajuste pueden añadirse con geom_smooth():\n\n\nCódigo\n# con CI\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  facet_wrap(~Species, scales = \"free\", nrow = 3)\n\n\n\n\n\n\n\n\n\nCódigo\n# sin CI\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  facet_wrap(~Species, scales = \"free\", nrow = 3)\n\n\n\n\n\n\n\n\n\n \n\nEjercicio 2\nUtilizando el conjunto de datos de ejemplo “msleep”:\n\n2.1 Crear un gráfico de dispersión de peso corporal (“bodywt”) frente a peso cerebral (“brainwt”)\n\n2.2 Añadir orden (“order”) como estética del color\n\n2.3 Añadir un componente “faceta” para dividir los gráficos por orden utilizando escalas libres\n\n2.4 Elimine los órdenes con menos de 4 especies en el conjunto de datos y haga un gráfico similar al 2.3\n\n2.5 Añadir una línea de mejor ajuste a cada gráfico del panel\n\n\n\n\n0.6.2 Boxplots\nDe nuevo, sólo se necesita un nuevo componente “geom” para crear un boxplot:\n\n\nCódigo\nggplot(iris, aes(Species, Petal.Length)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nUna alternativa interesante son los gráficos de violines:\n\n\nCódigo\nggplot(iris, aes(Species, Petal.Length)) +\n  geom_violin()\n\n\n\n\n\n\n\n\n\n \n\n\n0.6.3 Histogramas\nLo mismo ocurre con los histrogramas y los gráficos de frecuencias:\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_freqpoly()\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram() +\n  geom_freqpoly()\n\n\n\n\n\n\n\n\n\n \nPodemos controlar la anchura de las barras:\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram(binwidth = 1, fill = adjustcolor(\"red2\", alpha.f = 0.3))\n\n\nWarning: Duplicated aesthetics after name standardisation: fill\n\n\n\n\n\n\n\n\n\n \nY compara la distribución de los distintos grupos dentro del mismo histograma:\n\n\nCódigo\nggplot(iris, aes(Petal.Length, fill = Species)) +\n  geom_histogram(binwidth = 0.4)\n\n\n\n\n\n\n\n\n\n \n\n\n0.6.4 Gráfico de barras\nMuestran la distribución de variables discretas (categóricas):\n\n\nCódigo\ntab &lt;- table(msleep$order)\n\ndf &lt;-\n  as.data.frame(table(msleep$order[msleep$order %in% names(tab)[tab &gt; 3]]))\n\nggplot(df, aes(Var1, Freq)) +\n  geom_bar(stat = \"identity\")"
  },
  {
    "objectID": "ggplot2.html#personalización-de-ggplots",
    "href": "ggplot2.html#personalización-de-ggplots",
    "title": "Gráficos con ggplot2",
    "section": "0.7 Personalización de ggplots",
    "text": "0.7 Personalización de ggplots\nAdemás de las funciones básicas (por ejemplo, componentes) descritas anteriormente, ggplot tiene muchas otras herramientas (tanto argumentos como funciones adicionales) para personalizar aún más los gráficos. Prácticamente todo se puede modificar. Aquí vemos algunas de las herramientas más comunes.\n \n\n0.7.1 Temas\nggplot2 viene con algunos temas por defecto que se pueden aplicar fácilmente para modificar el aspecto de nuestros gráficos:\n\n\nCódigo\np &lt;- ggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\np + theme_classic()\n\n\n\n\n\n\n\n\n\nCódigo\np + theme_bw()\n\n\n\n\n\n\n\n\n\nCódigo\np + theme_minimal()\n\n\n\n\n\n\n\n\n\n \nLa mayoría de los temas difieren en el uso de cuadrículas, líneas de borde y patrones de etiquetado de ejes.\n \n\n\n0.7.2 Personalización de ejes\nLos límites de los ejes pueden modificarse como sigue:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  xlim(c(0, 10))\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  xlim(c(0, 10)) +\n  ylim(c(0, 9))\n\n\n\n\n\n\n\n\n\n \nLos ejes también pueden transformarse:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  scale_x_continuous(trans = \"log\") +\n  scale_y_continuous(trans = \"log2\")\n\n\n\n\n\n\n\n\n\n \no invertidos:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  scale_y_reverse()\n\n\n\n\n\n\n\n\n\n\n\n0.7.3 Guardar ggplots\nLos ggplots pueden exportarse como archivos de imagen utilizando la función ggsave:\n\n\nCódigo\nggplot(\n  data = msleep[msleep$order %in% names(tab)[tab &gt; 5], ],\n  mapping = aes(x = bodywt, y = brainwt)\n) +\n  geom_point() +\n  facet_wrap(~order, scales = \"free\")\n\n\nWarning: Removed 21 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nCódigo\n# Export\nggsave(\"plot.png\", width = 5, height = 5)\n\n\nWarning: Removed 21 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n \nEl tipo de archivo de imagen se identificará por la extensión en el nombre del archivo\n \nPersonalización adicional del eje:\n\n\nCódigo\n# Log2 scaling of the y axis (with visually-equal spacing)\nrequire(scales)\n\np + scale_y_continuous(trans = log2_trans())\n\n\n\n\n\n\n\n\n\nCódigo\n# show exponents\np + scale_y_continuous(\n  trans = log2_trans(),\n  breaks = trans_breaks(\"log2\", function(x) 2^x),\n  labels = trans_format(\"log2\", math_format(2^.x))\n)\n\n\n\n\n\n\n\n\n\nCódigo\n# Percent\np + scale_y_continuous(labels = percent)\n\n\n\n\n\n\n\n\n\nCódigo\n# dollar\np + scale_y_continuous(labels = dollar)\n\n\n\n\n\n\n\n\n\nCódigo\n# scientific\np + scale_y_continuous(labels = scientific)\n\n\n\n\n\n\n\n\n\nCódigo\n### Agregar \"tick marks\" ###\n\n# Cargar librerías\nlibrary(MASS)\n\ndata(Animals)\n\n# x and y axis are transformed and formatted\np2 &lt;- ggplot(Animals, aes(x = body, y = brain)) +\n  geom_point(size = 4) +\n  scale_x_log10(\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x))\n  ) +\n  scale_y_log10(\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x))\n  ) +\n  theme_bw()\n\n# log-log plot without log tick marks\np2\n\n\n\n\n\n\n\n\n\nCódigo\n# Show log tick marks\np2 + annotation_logticks()\n\n\n\n\n\n\n\n\n\nCódigo\n# # Log ticks on left and right\np2 + annotation_logticks(sides = \"lr\")\n\n\n\n\n\n\n\n\n\nCódigo\n# All sides\np2 + annotation_logticks(sides = \"trbl\")\n\n\n\n\n\n\n\n\n\n \n\n\n0.7.4 Otros gráficos\nSe pueden generar muchos otros tipos de gráficos. Aquí muestro un ejemplo de gráficos de contorno y de “mapa de calor”:\n\n\nCódigo\nhead(faithful)\n\n\n\n\n\n\neruptions\nwaiting\n\n\n\n\n3.600\n79\n\n\n1.800\n54\n\n\n3.333\n74\n\n\n2.283\n62\n\n\n4.533\n85\n\n\n2.883\n55\n\n\n\n\n\n\nCódigo\nggplot(faithfuld, aes(eruptions, waiting)) +\n  geom_contour(aes(z = density, colour = after_stat(level)))\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(faithfuld, aes(eruptions, waiting)) +\n  geom_raster(aes(fill = density))"
  },
  {
    "objectID": "ggplot2.html#otros-paquetes-de-gráficos-en-r",
    "href": "ggplot2.html#otros-paquetes-de-gráficos-en-r",
    "title": "Gráficos con ggplot2",
    "section": "0.8 Otros paquetes de gráficos en R",
    "text": "0.8 Otros paquetes de gráficos en R\n\nggvis (ggplots interactivos)\nvcd (Warnes 2015)\nplotrix (Lemon et al. 2006)\ngplots (Warnes 2015)\n\nConsulte la CRAN Graphics Task View para obtener una lista más completa de herramientas gráficas en R."
  },
  {
    "objectID": "ggplot2.html#references",
    "href": "ggplot2.html#references",
    "title": "Gráficos con ggplot2",
    "section": "0.9 References",
    "text": "0.9 References\n\nLemon J (2006) Plotrix: a package in the red light district of R. R-News 6(4):8–12\nWarnes GR, Bolker B, Bonebakker L, Gentleman R, Liaw WHA, Lumley T, Maechler M, Magnusson A, Moeller S, Schwartz M, Venables B (2015) gplots: various R programming tools for plotting data. R package version 2.17.0. https://CRAN.R-project.org/package=gplots\nWickham H (2010) A layered grammar of graphics. J Comput Graph Stat 19(1):3–28\nWilkinson L (2005) The grammar of graphics. Statistics and computing, 2nd edn. Springer, New York\n\n\n\nInformación de la sesión\n\n\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.4 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_CR.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_CR.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_CR.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_CR.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] scales_1.3.0       viridis_0.6.5      viridisLite_0.4.2  MASS_7.3-61       \n[5] RColorBrewer_1.1-3 ggplot2_3.5.1      knitr_1.48         kableExtra_1.4.0  \n\nloaded via a namespace (and not attached):\n [1] Matrix_1.7-0      gtable_0.3.5      jsonlite_1.8.8    dplyr_1.1.4      \n [5] compiler_4.4.1    tidyselect_1.2.1  xml2_1.3.6        stringr_1.5.1    \n [9] gridExtra_2.3     textshaping_0.4.0 splines_4.4.1     systemfonts_1.1.0\n[13] yaml_2.3.10       fastmap_1.2.0     lattice_0.22-6    R6_2.5.1         \n[17] labeling_0.4.3    generics_0.1.3    isoband_0.2.7     htmlwidgets_1.6.4\n[21] tibble_3.2.1      munsell_0.5.1     svglite_2.1.3     pillar_1.9.0     \n[25] rlang_1.1.4       utf8_1.2.4        stringi_1.8.4     xfun_0.47        \n[29] cli_3.6.3         mgcv_1.9-1        withr_3.0.1       magrittr_2.0.3   \n[33] digest_0.6.37     grid_4.4.1        rstudioapi_0.16.0 nlme_3.1-165     \n[37] lifecycle_1.0.4   vctrs_0.6.5       evaluate_0.24.0   glue_1.7.0       \n[41] farver_2.1.2      ragg_1.3.2        fansi_1.0.6       colorspace_2.1-1 \n[45] rmarkdown_2.28    tools_4.4.1       pkgconfig_2.0.3   htmltools_0.5.8.1"
  },
  {
    "objectID": "funciones.html#funciones-integradas",
    "href": "funciones.html#funciones-integradas",
    "title": "Funciones",
    "section": "2.1 Funciones integradas",
    "text": "2.1 Funciones integradas\n\n2.1.1 Funciones básicas\nR viene con muchas funciones que puedes usar para hacer tareas sofisticadas:\n\n\nCódigo\n# built in functions\nbi &lt;- builtins(internal = FALSE)\n\nlength(bi)\n\n\n[1] 1402\n\n\n \nAlgunas funciones vienen de forma predeterminada con R básico. Nuevas funciones pueden ser cargadas como parte de paquetes adicionales o incluso creadas por el usuario.\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    F(Funciones) --&gt; BF(Funciones Integradas)\n    BF --&gt; OP(Operadores)\n    BF --&gt; BA(Funciones Básicas)\n    F --&gt; PF(Paquetes)\n    F --&gt; UF(Funciones Definidas por el Usuario)\n\n    class R,D,D1,D2,F largeText;\n\n    style F fill:#357BA266, stroke:#000, stroke-width:2px, color:#FFF, width:120px\n    style BF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n    style BA fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000\n    style OP fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000    \n    style PF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000000\n    style UF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n2.1.2 Operadores\nLos operadores son funciones:\n\n\nCódigo\n1 + 1\n\n\n[1] 2\n\n\nCódigo\n'+'(1, 1)\n\n\n[1] 2\n\n\nCódigo\n2 * 3\n\n\n[1] 6\n\n\nCódigo\n'*'(2, 3)\n\n\n[1] 6\n\n\n \n\n2.1.2.1 Operadores mas utilizados\nOperadores aritméticos:\n\n\n\n\n\n\n\nOperador\nDescrición\n\n\n\n\n+\nsuma\n\n\n-\nresta\n\n\n*\nmultiplicación\n\n\n/\ndivisión\n\n\n^ or **\nexponente\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n1 - 2\n\n\n[1] -1\n\n\nCódigo\n1 + 2\n\n\n[1] 3\n\n\nCódigo\n2 ^ 2\n\n\n[1] 4\n\n\nCódigo\n2 ** 2\n\n\n[1] 4\n\n\n \nOperadores lógicos:\n\n\n\nOperador\nDescrición\n\n\n\n\n&lt;\nmenor que\n\n\n&lt;=\nmenor o igual que\n\n\n&gt;\nmayor que\n\n\n&gt;=\nmayor o igual que\n\n\n==\nexactamente igual que\n\n\n!=\ndiferente que\n\n\n!x\nNo es x\n\n\nx | y\nx O y\n\n\nx & y\nx Y y\n\n\nx %in% y\ncorrespondencia\n\n\n\n\n\nCódigo\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 == 2\n\n\n[1] FALSE\n\n\nCódigo\n1 != 2\n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCódigo\n5 %in% 1:4\n\n\n[1] FALSE\n\n\nLos paréntesis utilizados para extraer subconjuntos de objetos también son funciones:\n\n\nCódigo\nletters[3:4]\n\n\n[1] \"c\" \"d\"\n\n\nCódigo\n\"[\"(letters, 3:4)\n\n\n[1] \"c\" \"d\"\n\n\n \n\n\n\n2.1.3 Vectorización\nLa mayoría de las funciones están vectorizadas:\n\n\nCódigo\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCódigo\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recicla vectores de longitud desigual:\n\n\nCódigo\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n\n \n\n2.1.4 Funciones de paquetes adicionales\nEstas son funciones que son incluidas en paquetes adicionales que se pueden instalar y cargar en R. Para ser utilizadas el paquete debe ser instalado y cargado.Por ejemplo para usar la función corTest del paquete “psych” primero debemos instalar. Los paquetes son instalados del servidor de CRAN (Comprehensive R Archive Network) con la función install.packages():\n\n\nCódigo\ninstall.packages(\"psych\")\n\n\n.. y cargar el paquete:\n\n\nCódigo\nlibrary(psych)\n\n\nUna vez instalado y cargado ‘psych’, podemos llamar a la función corTest:\n\n\nCódigo\ncorTest(iris$Sepal.Length, iris$Sepal.Width)\n\n\nCall:corTest(x = iris$Sepal.Length, y = iris$Sepal.Width)\nCorrelation matrix \n[1] -0.12\nSample Size \n[1] 150\nThese are the unadjusted probability values.\n  The probability values  adjusted for multiple tests are in the p.adj object. \n[1] 0.15\n\n To see confidence intervals of the correlations, print with the short=FALSE option\n\n\nEl uso de paquetes externos es la caracteristica mas util de R ya que permite hacer uso de un número casi infinito de funciones especializadas en diferentes tareas así como de campos muy diversos de la ciencia y la industria.\nPodemos explorar los paquetes disponibles para R en la página de CRAN (hacer click en el enlace “packages”).\n\n\n2.1.5 Ejercicio 2\n\nBusque un paquete que le interese en CRAN\nInstale el paquete y carguelo\nCorra el codigo de ejemplo de una de sus funciones"
  },
  {
    "objectID": "funciones.html#ejercicio-2-1",
    "href": "funciones.html#ejercicio-2-1",
    "title": "Funciones",
    "section": "3.5 Ejercicio 2",
    "text": "3.5 Ejercicio 2\n2.1 Cree una función llamada promedio que calcule el promedio de un vector numérico. Internamente solo puede utilizar las funciones sum() y length() (suma y división, no puede llamar la función mean())\n2.2 Cree una función que tome 2 argumentos numéricos (llámelos ‘x’ y ‘y’), eleve cada uno al cuadrado y luego los sume\n2.3 Agregue valores predeterminados a cada argumento\n2.4 Ejecute la función usando los valores predeterminados\n2.5 Ejecute la función usando un valor predeterminado y uno proporcionado en la llamada\n2.6 Ejecute la función proporcionando ambos valores en la llamada"
  }
]